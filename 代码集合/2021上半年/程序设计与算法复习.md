### 期中测试习题

>>  7-1 求和1到n (10分)

计算1+2+3+⋯+n。

测试点分别为：1、10、10000、100000、1000000、10000000、100000000、1000000000、2147483647

输入格式:
一行，一个不超过32位int型的正整数。

输出格式:
求和的结果。

输入样例:
10

输出样例:
55

```c
#include<iostream>
using namespace std;
long long sum = 0;
int main()
{
    long long n;
    cin>>n;
    cout<<(n*(n+1)/2)<<endl;

    return 0;
}
```

>> 7-2 分巧克力 (10分)

儿童节那天有K位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。
小明一共有N块巧克力，其中第i块是H
​i
​​ ×W
​i
​​ 的方格组成的长方形。

为了公平起见，小明需要从这 N 块巧克力中切出K块巧克力分给小朋友们。切出的巧克力需要满足：

1. 形状是正方形，边长是整数  
2. 大小相同  
例如一块6×5的巧克力可以切出6块2×2的巧克力或者2块3×3的巧克力。

当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少吗？

输入格式:
第一行包含两个整数N和K。(1≤N,K≤100000)

以下N行每行包含两个整数H
​i
​​ 和W
​i
​​ 。(1≤H
​i
​​ ,W
​i
​​ ≤100000)

输入保证每位小朋友至少能获得一块1×1的巧克力。

输出格式:
输出切出的正方形巧克力最大可能的边长。

输入样例:

2 10

6 5

5 6

输出样例:
2

>> 注意mid的取整
```c
#include<iostream>
#include<iomanip>
using namespace std;
const int MAX_S = 100005;
double h[MAX_S],w[MAX_S];
int N,K;
bool judge(int c)
{
    int cnt = 0;
    for(int i = 0;i < N;++i)
    {
        cnt += (h[i]/c)*(w[i]/c);
    }
    return cnt >= K;
}
int main()
{
    cin>>N>>K;
    for(int i = 0;i < N;++i)
    {
        cin>>h[i]>>w[i];
    }
    int l = 1,r = 1<<30;
    while(l < r)
    {
        int mid = (l + r + 1)/2;
        if(judge(mid))
        {
            l = mid;
        }
        else 
        {
            r = mid - 1;
        }
    }
    cout<<l<<endl;

    return 0;
}
```
>> 7-3 数水洼 (10分)

大小为N×M的菜园，因为下雨有积水，八连通的积水被认为连在一起构成一个水洼。

计算菜园里有多少个水洼。(1≤N≤100;1≤M≤100)

八连通指的是

\***

\*W*

\***

输入格式:
第一行是两个整数N和M，表示菜园的大小。

接下来有N行M列，句点.表示地面，大写W表示积水。

输出格式:
一个整数，表示水洼数。

输入样例:
```
10 12

 W........WW.

.WWW.....WWW

....WW...WW.

.........WW.

.........W..

..W......W..

.W.W.....WW.

W.W.W.....W.

.W.W......W.

..W.......W.
```

输出样例:
3

代码长度限制
16 KB
时间限制
100 ms
内存限制
64 MB

```c
#include<iostream>
#include<algorithm>
using namespace std;
const int MAX_V = 110;
char a[MAX_V][MAX_V];
int N,M;
void dfs(int x,int y)
{
    a[x][y] = '.';
    for(int i = -1;i < 2;++i)
    {
        for(int j = -1;j < 2;++j)
        {
            int nx = x + i,ny = y + j;
            if(nx >= 0 && nx < N && ny >= 0 && ny < M && a[nx][ny] != '.')
            {
                dfs(nx,ny);
            }
        }
    }
}
int main()
{
    cin>>N>>M;
    for(int i = 0;i < N;++i)
    {
        for(int j = 0;j < M;++j)
        {
            cin>>a[i][j];
        }
    }
    int ans = 0;
    for(int i = 0;i < N;++i)
    {
        for(int j = 0;j < M;++j)
        {
            if(a[i][j] != '.')
            {
                dfs(i,j);
                ++ans;
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
>> 7-4 迷宫 (10分)

下图给出了一个迷宫的平面图，其中标记为1的为障碍，标记为0的为可以通行的地方。

010000
000100
001001
110000
迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这个它的上、下、左、右四个方向之一。

对于上面的迷宫，从入口开始，可以按DRRURRDDDR的顺序通过迷宫，一共 10 步。

其中 D、 U、 L、 R 分别表示向下、向上、向左、向右走。

对于一个n行m列的迷宫（n≤30,m≤50），请找出一种通过迷宫的方式，其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。

请注意在字典序中D<L<R<U。

输入格式:
第一行两个整数n和m，分别表示迷宫的行数和列数。

接下来n行，每行由长度为m的01串组成。

输出格式:
一个字符串。

输入样例:
```
4 6
010000
000100
001001
110000
```
输出样例:
```
DRRURRDDDR
```

代码长度限制
16 KB
时间限制
400 ms
内存限制
64 MB

> 注意障碍物和非障碍物
```c

#include<iostream>
#include<string>
#include<queue>
#include<cstring>
using namespace std;
using pii = pair<int,int>;
const int MAX_V = 110;
string str = "DLRU";
int dx[4] = {1,0,0,-1};
int dy[4] = {0,-1,1,0};
char a[MAX_V][MAX_V];
bool visited[MAX_V][MAX_V];
int N,M;
int R,C;
struct edge
{
    int x,y;
    char w;
    int dis;
};
edge pre[MAX_V][MAX_V];
void printPath(edge v)
{
    string ans  = "";
    while(true)
    {
        ans = v.w + ans;
        v = pre[v.x][v.y];
        if(v.x == 0 && v.y == 0)
            break;
    }
    cout<<ans<<endl;
}
void bfs()
{
    memset(visited,0,sizeof(visited));
    queue<edge> pq;
    visited[0][0] = 1;
    pq.push({0,0,'-',1});
    while(!pq.empty())
    {
        auto v = pq.front();
        pq.pop();

        if(v.x == R && v.y == C)
        {
            printPath(v);
            break;
        }
        for(int i = 0;i < 4;++i)
        {
            int nx = v.x + dx[i];
            int ny = v.y + dy[i];
            if(nx >= 0 && nx < N && ny >= 0 && ny < M && a[nx][ny] == '0' && !visited[nx][ny])
            {
                visited[nx][ny] = 1;
                pre[nx][ny] = v;
                pq.push({nx,ny,str[i],v.dis + 1});
            }
        }
    }
}
int main()
{
    cin>>N>>M;
    getchar();
    string cs;
    for(int i = 0;i < N;++i)
    {
        getline(cin,cs);
        for(int j = 0;j < cs.size();++j)
        {
            a[i][j] = cs[j];
        }
    }
    R = N - 1;
    C = M - 1;
    bfs();
    return 0;
}
```

> 7-5 破损棋盘上的N皇后问题 (10分)

会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8 * 8个格子），使它们谁也不能被吃掉。这就是著名的八皇后问题。

但是，现在棋盘是破损的，有些格子里不能放棋子。这样的N皇后问题，有多少个解？

输入格式:
一行，一个正整数N(N≤16)。

接下来N行，每行N个由空格隔开的数，表示棋盘的情况：为0，表示此处没坏；为1，表示此处坏了，不能放棋子。

输出格式:
一行，输出不同的解的数量。

输入样例:
```
4
1 0 1 1
1 1 1 0
0 1 1 1
1 1 0 1
```
输出样例:
```
1
```
>> 注意判别 横着 竖着 斜着 不能被吃掉，斜着可以用数学线性函数来代替，这里从第一列开始枚举每行的方法（注意恢复现场信息），直到某种选择能够枚举到所有列结束后才计为一种成功的策略，一定要用bool来判断是否可以放棋子
```c

#include<iostream>
using namespace std;
const int MAX_V = 20;
int a[MAX_V][MAX_V];
bool c[MAX_V] , ad[MAX_V], d[MAX_V];
int N,ans = 0;
void dfs(int k)
{
    int i;
    if(k == N)
    {
        ++ans;
        return;
    }
    for( i = 0;i < N;++i)
    {
        if(!c[i] && !ad[k - i + N] && a[i][k] == 0 && !d[k + i])
        {
            c[i] = ad[k - i + N] = d[k + i]  = true;
            dfs(k + 1);
            c[i] = ad[k - i + N] = d[k + i]  = false;
        }

    }
}
int main()
{
    cin>>N;
    for(int i = 0;i < N;++i)
    {
        for(int j = 0;j < N;++j)
        {
            cin>>a[i][j];
        }
    }
    dfs(0);
    cout<<ans<<endl;
    return 0;
}
```

> 7-6 受欢迎的牛 (10分)

牛的愿望就是变成一头最受欢迎的牛。现在有N头牛、M对整数(A,B)，表示牛A认为牛B受欢迎。 这种关系是具有传递性，即：如果A认为B受欢迎，B认为C受欢迎，那么A也认为C受欢迎。

你的任务是求出有多少头牛被所有的牛认为是受欢迎的。

输入格式:
第一行两个数N和M（N≤10000,M≤50000）。

接下来M行，每行两个数A,B，意思是A认为B是受欢迎的（给出的信息有可能重复，即有可能出现多个A,B）。

输出格式:
一个数，即有多少头牛被所有的牛认为是受欢迎的。

输入样例:
```
3 3
1 2
2 1
2 3
```
输出样例:
```
1
```

```c
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
vector<vector<int> > rG,G;
vector<int> d,post,cntFlag;
vector<bool> visited;
int N,M,ts = 0,sccNum,ans = 0;
void dfs(int x)
{
    d[x] = ++ts;
    for(auto w : G[x])
    {
        if(d[w] == 0)
            dfs(w);
    }
    post.push_back(x);
}
void rdfs(int x)
{
    cntFlag[x] = sccNum;
    for(auto w : rG[x])
    {
        if(cntFlag[w] == 0)
        {
            rdfs(w);
        }
    }

}
bool dfs3(int x)
{
    ++ans;
    visited[x] = true;
    for(auto w : rG[x])
    {
        if(!visited[w])
            dfs3(w);
    }
}
int sccC()
{
    fill(d.begin(),d.end(),0);
    for(int i = 1;i <= N;++i)
    {
        if(d[i] == 0)
            dfs(i);
    }
    reverse(post.begin(),post.end());
    sccNum = 0;
    for(auto i : post)
    {
        if(cntFlag[i] == 0)
        {
            ++sccNum;
            rdfs(i);
        }
    }
    int cnt = 0;
    for(int i = 1;i <= N;++i)
    {
        if(cntFlag[i] == sccNum)
        {
            fill(visited.begin(),visited.end(),false);
            ans = 0;
            dfs3(i);
            if(ans == N)
                ++cnt;
        }
    }
    return cnt;
}
int main()
{
    cin>>N>>M;
    rG.resize(N+1);
    G.resize(N+1);
    cntFlag.resize(N+1);
    visited.resize(N+1);
    d.resize(N+1);
    while(M--)
    {
        int x,y;
        cin>>x>>y;
        G[x].push_back(y);
        rG[y].push_back(x);
    }
    cout<<sccC()<<endl;

    return 0;
}
```
>> 7-7 图的基本概念——结点的度 (10分)

无向图，计算图的最大度、最小度。

图的最大度指的是图中所有结点的度的最大值，图的最小度指的是图中所有结点的度的最小值。

输入格式:
第一行是一个整数V，表示图有V个结点，结点编号0,1,2,...,V−1。（1≤V≤10,000）

第二行是一个整数E，表示图中有E条边。（0≤E≤100,000）

接下来有E行，每行表示一条边，用空格分隔的两个整数表示边的两个端点。

输出格式:
两行，每行一个整数，分别表示图的最大度、最小度。

输入样例:
```
13
13
0 5
4 3
0 1
9 12
6 4
5 4
0 2
11 12
9 10
0 6
7 8
9 11
5 3
```
输出样例:
```
4
1
```

代码长度限制
16 KB
时间限制
400 ms
内存限制
64 MB


```c
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
vector<vector<int> > G;
vector<int> degree;
int V,E;
int main()
{
    cin>>V>>E;
    G.resize(V);
    degree.resize(V);
    for(int i = 0;i < E;++i)
    {
        int x,y;
        cin>>x>>y;
        ++degree[x];
        ++degree[y];
        G[x].push_back(y);
        G[y].push_back(x);
    }
    cout<<*max_element(degree.begin(),degree.end())<<endl;
    cout<<*min_element(degree.begin(),degree.end())<<endl;
    return 0;
}
```

>>7-8 最小生成树 (10分)

计算带权无向连通图G的最小生成树。

输入格式:
第一行两个整数：N（1≤N≤300000），表示结点集；表示边的条数。

接下来M行，每行表示一条带权的边，用3个整数u,v,c表示，分别表示一条边的两个端点以及其权值（权值范围0≤c≤10
​9
​​ ）。

输出格式:
一个整数，表示G的最小生成树的边权之和。

输入样例:
```
5 10
1 2 3
1 3 7
1 4 9
1 5 5
2 3 6
2 4 8
2 5 4
3 4 9
3 5 7
4 5 2
```
输出样例:
```
15
```
> 首先将边存储下来，按照权值从小到大排序，开始并操作
```c
#include<iostream>
#include<algorithm>
#include<vector>
#include<numeric>
#define LL long long
using namespace std;
using pii = pair<LL,LL>;
struct edge
{
    int x,y,w;
};
vector<edge> g;
vector<LL> pa;
LL N,M;
LL find(LL x)
{
    return pa[x] == x ? x : find(pa[x]);
}
LL Kruscal()
{
    LL ans = 0,cnt = 0;
    iota(pa.begin(),pa.end(),0);
    sort(g.begin(),g.end(),[](auto &e1,auto &e2){return e1.w < e2.w;});
    for(auto e : g)
    {
        int nx = find(e.x);
        int ny = find(e.y);
        if(nx == ny)
            continue;
        ans += e.w;
        if(nx < ny)
            pa[ny] = nx;
        else 
            pa[nx] = ny;
        if(++cnt == N-1)
            break;
    }
    return (cnt == N - 1 ? ans : -1);
}
int main()
{
    cin>>N>>M;
    pa.resize(N+1);
    for(LL i = 0;i < M;++i)
    {
        LL x,y,z;
        cin>>x>>y>>z;
        g.push_back({x,y,z});
    }
    cout<<Kruscal()<<endl;
    return 0;
}
```
