## 第十一届蓝桥杯大赛第二次模拟（软件类）真题

 #### 1.12.5MB

【问题描述】
在计算机存储中，12.5MB是多少字节？
【答案提交】
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

<b>考点： 字节的转换</b>

总结：

  ```c++
这是一个填空题，只需要填写答案即可。因为1MB = 1024KB,1KB = 1024B，所以12.5MB = 12.5 * 1024 * 1024 = 12800KB * 1024 = 13107200 B。所以答案为13107200

#include<iostream>
using namespace std;
int main()
{
    cout<<(long long)(12.5*1024*1024)<<endl;
}
  ```

#### 2.最多边数

【问题描述】
一个包含有2019个结点的有向图，最多包含多少条边？（不允许有重边）
【答案提交】
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

<b>考点：无向图</b>

总结：无向图的最大边，最小边

```c++
这是一个填空题，只需要填写答案即可。一个n个结点的无相连通图最少需要N-1条边。需要注意这里是无向的。所以答案为2018

一个有n个顶点的无向连通图最多有n（n-1）/2条边，最少有n-1条边。
```

#### 3.单词重排

【问题描述】
将LANQIAO中的字母重新排列，可以得到不同的单词，如LANQIAO、AAILNOQ等，注意这7个字母都要被用上，单词不一定有具体的英文意义。
请问，总共能排列如多少个不同的单词。
【答案提交】
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

<b>考点：全排列</b>

总结：N！(n的阶乘)

```c++
这是一个填空题，只需要填写答案即可。7的字母的全排列，7个都要用上，即是7! = 7 * 6 * 5 * 4 * 3 * 2 * 1 = 5040。这里由于A有2个，所以我们需要再处于A22,即5040/2 = 2520即答案为2520
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
    string s = "LANQIAO";
    sort(s.begin(),s.end());
    int cnt = 0;
    do{
        cnt++;
        cout<<s<<endl;
    }while(next_permutation(s.begin(),s.end()));
    cout<<cnt<<endl;
    return 0;
}
```

#### 4.括号序列

【问题描述】
由1对括号，可以组成一种合法括号序列：()。
由2对括号，可以组成两种合法括号序列：()()、(())。
由4对括号组成的合法括号序列一共有多少种？
【答案提交】
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

考点：全排列 ，括号匹配

总结：

```c++
直接查找卡特兰数
用栈模拟，左括号相当于入栈，右括号相当于出栈，这样将题目转换成了统计出入栈序列总数了。
```

<b>扩展</b>:给定字符序列判断是否为合法的括号序列

```c++
#include<iostream>
#include<string>
using namespace std;
bool check(string s)
{
    //记录是否有左括号
    int left = 0;
    for(int i = 0;i < s.size();++i)
    {
        if(s[i] == '(')
        {
            left++;//如果是左括号
        }
        else if(s[i] == ')') //如果是右括号
        {
            if(left)//如果有左括号(左边是左括号)
            {
                left--;
            }
            else //没有左括号，返回不合法
            {
                return false;
            }
        }
        else //是其它的符号（不合法）
        {
            return false;
        }
    }
    return !left;//是否有多余的左括号
}
int main()
{
    string s;
    cin>>s;
    cout<<check(s)<<endl;
    return 0;
}
```

##### 给定字符判断有几种合法的括号排列（如果不只是有4对这种方法便非常局限）

```c++
#include<iostream>
#include<string>
#include<algorithm>
int main()
{
    string s = "(((())))";
    int cnt = 0;
    do
    {
        if(check(s))
        {
            cout<<s<<endl;
            cnt++;
        }
    } while (next_permutation(s.begin(),s.end()));
    cout<<cnt<<endl;
    return 0;
}
```

##### 输入对应的括号对数，输出合法序列的数目

```c++
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
//将要放进的左括号， 已经放进的左括号
int dfs(int willInLeft,int isInleft)
{
    //出口
    if(willInLeft <= 0 && isInleft <= 0)//都为零
        return 1;
    int sum = 0;
    if(willInLeft)//放入一个左括号
    {
        //将要放入的左括号减1      放入的左括号加1
        sum += dfs(willInLeft - 1,isInleft + 1);//
    }
    //如果前面还有为匹配的左括号。那么就可以放入一个右括号进来
    if(isInleft)//放入一个右括号。
    {
        //此时将要放入的左括号数目（左括号剩余的数目）不变，
        //但是能够匹配的数目减一
        sum += dfs(willInLeft,isInleft - 1);
    }
    return sum;
}
int main()
{
    int n;
    cin>>n;//N对括号，则需要放入N个左括号
    cout<<dfs(n,0)<<endl;//有n个左括号没有放入，0个左括号放进去了
    return 0;
}
```

#### 在dfs中加入对应的前缀，即可输出对应的种类

```c++
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
//将要放进的左括号， 已经放进的左括号
int dfs(int willInLeft,int isInleft,string pre)
{
    //出口
    if(willInLeft <= 0 && isInleft <= 0)//都为零
    {   
        cout<<pre<<endl;
        return 1;
    }
    int sum = 0;
    if(willInLeft)//放入一个左括号
    {
        //将要放入的左括号减1      放入的左括号加1
        sum += dfs(willInLeft - 1,isInleft + 1,pre + "(");//
    }
    //如果前面还有为匹配的左括号。那么就可以放入一个右括号进来
    if(isInleft)//放入一个右括号。
    {
        //此时将要放入的左括号数目（左括号剩余的数目）不变，
        //但是能够匹配的数目减一
        sum += dfs(willInLeft,isInleft - 1,pre + ")");
    }
    return sum;
}
int main()
{
    int n;
    cin>>n;//N对括号，则需要放入N个左括号
    cout<<dfs(n,0,"")<<endl;//有n个左括号没有放入，0个左括号放进去了
    return 0;
}
```

> ### 记忆化搜索进行优化

```c++
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
int all[100][100];//记录数组
//将要放进的左括号， 已经放进的左括号
int dfs(int willInLeft,int isInleft)
{
    if(all[willInLeft][isInleft])
        return all[willInLeft][isInleft];
    if(willInLeft <= 0 && isInleft <= 0)
    {  
        return 1;
    }
    int sum = 0;
    if(willInLeft)
    {
        sum += dfs(willInLeft - 1,isInleft + 1);
    }
    if(isInleft)
    {
        sum += dfs(willInLeft,isInleft - 1);
    }
    return (all[willInLeft][isInleft] = sum);
}
int main()
{
    int n;
    cin>>n;
    cout<<dfs(n,0)<<endl;
    for(int i = 0;i < n;++i)
    {
        for(int j = 0;j < n;++j)
        {
            cout<<all[i][j];
            cout<<(j != n-1 ? " " : "\n");
        }
    }
    cout<<all[4][0]<<endl;
    return 0;
}
```

### 5.反倍数

【问题描述】
给定三个整数 a, b, c，如果一个整数既不是 a 的整数倍也不是 b 的整数倍还不是 c 的整数倍，则这个数称为反倍数。
请问在 1 至 n 中有多少个反倍数。
【输入格式】
输入的第一行包含一个整数 n。
第二行包含三个整数 a, b, c，相邻两个数之间用一个空格分隔。
【输出格式】
输出一行包含一个整数，表示答案。
【样例输入】
30
2 3 6
【样例输出】
10
【样例说明】
以下这些数满足要求：1, 5, 7, 11, 13, 17, 19, 23, 25, 29。
【评测用例规模与约定】
对于 40% 的评测用例，1 <= n <= 10000。
对于 80% 的评测用例，1 <= n <= 100000。
对于所有评测用例，1 <= n <= 1000000，1 <= a <= n，1 <= b <= n，1 <= c <= n。

> 考点：模拟题，取余

> 总结：

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int n,a,b,c,cnt = 0;
bool judge(int x)
{
    return (x % a != 0)&&(x % b != 0)&&(x % c != 0);
}
int main()
{
    cin>>n;
    cin>>a>>b>>c;
    for(int i = 1;i <= n;++i)
    {
        if(judge(i))
            ++cnt;
    }
    cout<<cnt<<endl;
    return 0;
}
```

#### 6.凯撒加密

【问题描述】
给定一个单词，请使用凯撒密码将这个单词加密。
凯撒密码是一种替换加密的技术，单词中的所有字母都在字母表上向后偏移3位后被替换成密文。即a变为d，b变为e，...，w变为z，x变为a，y变为b，z变为c。
例如，lanqiao会变成odqtldr。
【输入格式】
输入一行，包含一个单词，单词中只包含小写英文字母。
【输出格式】
输出一行，表示加密后的密文。
【样例输入】
lanqiao
【样例输出】
odqtldr
【评测用例规模与约定】
对于所有评测用例，单词中的字母个数不超过100。

> 考点：字符串，取余操作
>
> 总结：

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str;
    getline(cin,str);
    for(auto &c : str)
    {
        char x = (c - 'a' + 3)%26 + 'a';
        cout<<x;
    }
    cout<<endl;
    return 0;
}
```

#### 7.螺旋

【问题描述】
对于一个 n 行 m 列的表格，我们可以使用螺旋的方式给表格依次填上正整数，我们称填好的表格为一个螺旋矩阵。
例如，一个 4 行 5 列的螺旋矩阵如下：
1 2 3 4 5
14 15 16 17 6
13 20 19 18 7
12 11 10 9 8
【输入格式】
输入的第一行包含两个整数 n, m，分别表示螺旋矩阵的行数和列数。
第二行包含两个整数 r, c，表示要求的行号和列号。
【输出格式】
输出一个整数，表示螺旋矩阵中第 r 行第 c 列的元素的值。
【样例输入】
4 5
2 2
【样例输出】
15
【评测用例规模与约定】
对于 30% 的评测用例，2 <= n, m <= 20。
对于 70% 的评测用例，2 <= n, m <= 100。
对于所有评测用例，2 <= n, m <= 1000，1 <= r <= n，1 <= c <= m。

> 考点：数组，边界条件的处理
>
> 总结：

```c++

#include<iostream>
using namespace std;
int all[1005][1005];
int n,m,r,c;
void judge()
{
    for(int i = 1;i <= n;++i)
    {
        for(int j = 1;j <= m;++j)
        {
            all[i][j] = 0;
        }
    }
    int cnt = 1,x = 1,y = 1;
    all[x][y] = cnt;
    while(cnt != n*m)
    {
        //right
        while(y + 1 <= m && !all[x][y + 1])
            all[x][++y] = ++cnt;
        while(x + 1 <= n && !all[x + 1][y])//down
            all[++x][y] = ++cnt;
        while(y - 1 >= 1 && !all[x][y - 1])
            all[x][--y] = ++cnt;
        while(x - 1 >= 1 && !all[x - 1][y])
            all[--x][y] = ++cnt;
    }
    for(int i = 1;i <= n;++i)
    {
        for(int j = 1;j <= m;++j)
        {
            cout<<all[i][j]<<(j != m ? " " : "\n");
        }
    }
}
int main()
{
    cin>>n>>m;
    cin>>r>>c;
    judge();
    cout<<all[r][c]<<endl;
    return 0;
}
```

#### 8.摆动序列

【问题描述】
如果一个序列的奇数项都比前一项大，偶数项都比前一项小，则称为一个摆动序列。即 a[2i]<a[2i-1], a[2i+1]>a[2i]。
小明想知道，长度为 m，每个数都是 1 到 n 之间的正整数的摆动序列一共有多少个。
【输入格式】
输入一行包含两个整数 m，n。
【输出格式】
输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。
【样例输入】
3 4
【样例输出】
14
【样例说明】
以下是符合要求的摆动序列：
2 1 2
2 1 3
2 1 4
3 1 2
3 1 3
3 1 4
3 2 3
3 2 4
4 1 2
4 1 3
4 1 4
4 2 3
4 2 4
4 3 4
【评测用例规模与约定】
对于 20% 的评测用例，1 <= n, m <= 5；
对于 50% 的评测用例，1 <= n, m <= 10；
对于 80% 的评测用例，1 <= n, m <= 100；
对于所有评测用例，1 <= n, m <= 1000。

> 考点：深度搜索，动态规划
>
> 总结：最朴素的做法就是 <b>dfs</b>搜索，按 n m 的范围太大了，会超时

```c++
#include<iostream>
using namespace std;
int all[1010];
int m,n;
int cnt = 0;
void prt()
{
    for(int i = 1;i <= m;++i)
    {
        cout<<all[i]<<(i != m ? " " : "\n");
    }
}
void dfs(int now)
{
    if(now > m)
    {
        cnt++;
        prt();
        return;
    }
    for(int i = 1;i <= n;++i)
    {
        if(now % 2)
        {
            if(i > all[now - 1])
            {
                all[now] = i;
                dfs(now + 1);
            }
        }
        else 
        {
            if(i < all[now - 1])
            {
                all[now] = i;
                dfs(now + 1);
            }
        }
    }
}
int main()
{
    cin>>m>>n;
    dfs(1);
    cout<<cnt<<endl;
    return 0;
}

```

> 动态规划解析：首先确定公式的含义。
>
> 定义```dp[i][j]``` 表示第 i 项上放置比 j 大或小的数字的方案数，如何是偶数项就是比 j 小，奇数项就是比 j 大。
>
> 然后预处理条件，第一项的情况是固定的，```dp[i][j]``` 肯定是 n - j + 1 ，因为比 j 大的数只有这么多。
>
> 接下来就是遍历每一行了。
>
> 奇数项的公式为```dp[i][j] = dp[i - 1][j - 1] + dp[i][j+1]```找到等于 j 的情况数和大于 j 的情况数然后加起来，```dp[i - 1][j - 1]```表示前一项所有小于```j - 1  ```的情况数，```dp[i][j + 1]```表示当前项所有大于```j```的情况数。
>
> 偶数项的公式为```dp[i][j] = dp[i - 1][j + 1] + dp[i][j - 1]```，具体思路和上面一样，只不过方向换了。
>
> 最后注意遍历顺序就行了。

```c++
#include<iostream>
using namespace std;
int dp[1004][1004];
int main()
{
    int m,n;
    cin>>m>>n;
    for(int i = 1;i <= n;++i)
    {
        dp[1][i] = n - i + 1;
    }
    for(int i = 2;i <= m;++i)
    {
        if(i%2)
        {
            for(int j = n;j >= 1;--j)
            {
                dp[i][j] = (dp[i - 1][j-1] + dp[i][j + 1]) % 10000;
            }
        }
        else 
        {
            for(int j = 1;j <= n;++j)
            {
                dp[i][j] = (dp[i - 1][j + 1] + dp[i][j-1]) % 10000;
            }
        }
    }
    for(int i = 1;i <= n;++i)
    {
        for(int j = 1;j <= n;++j)
        {
            cout<<dp[i][j]<<(j != n ? " " : "\n");
        }
    }
    cout<<(m % 2 ? dp[m][1] : dp[m][n])<<endl;
    return 0;
}
```



#### 9.通电

【问题描述】
2015年，全中国实现了户户通电。作为一名电力建设者，小明正在帮助一带一路上的国家通电。
这一次，小明要帮助 n 个村庄通电，其中 1 号村庄正好可以建立一个发电站，所发的电足够所有村庄使用。
现在，这 n 个村庄之间都没有电线相连，小明主要要做的是架设电线连接这些村庄，使得所有村庄都直接或间接的与发电站相通。
小明测量了所有村庄的位置（坐标）和高度，如果要连接两个村庄，小明需要花费两个村庄之间的坐标距离加上高度差的平方，形式化描述为坐标为 (x_1, y_1) 高度为 h_1 的村庄与坐标为 (x_2, y_2) 高度为 h_2 的村庄之间连接的费用为
sqrt((x_1-x_2)*(x_1-x_2)+(y_1-y_2)*(y_1-y_2))+(h_1-h_2)*(h_1-h_2)。
在上式中 sqrt 表示取括号内的平方根。请注意括号的位置，高度的计算方式与横纵坐标的计算方式不同。
由于经费有限，请帮助小明计算他至少要花费多少费用才能使这 n 个村庄都通电。
【输入格式】
输入的第一行包含一个整数 n ，表示村庄的数量。
接下来 n 行，每个三个整数 x, y, h，分别表示一个村庄的横、纵坐标和高度，其中第一个村庄可以建立发电站。
【输出格式】
输出一行，包含一个实数，四舍五入保留 2 位小数，表示答案。
【样例输入】
4
1 1 3
9 9 7
8 8 6
4 5 4
【样例输出】
17.41
【评测用例规模与约定】
对于 30% 的评测用例，1 <= n <= 10；
对于 60% 的评测用例，1 <= n <= 100；
对于所有评测用例，1 <= n <= 1000，0 <= x, y, h <= 10000。

> 考点：最小生成树，prim，克鲁斯卡尔算法
>
> 总结：注意费用的计算公式

```c++
#include<iostream>
#include<vector>
#include<numeric>
#include<cmath>
#include<algorithm>
using namespace std;
vector<int> pre(10005);
struct node
{
    int x,y,h;
};
node all[10005];
int N;
struct pii
{
    int from,to;
    double cost;
    bool operator<(const pii& e)const
    {
        return cost < e.cost;
    }
};
vector<pii> edge; 
double getTotal(node &e1,node &e2)
{
    return sqrt(abs(e1.x - e2.x) * abs(e1.x - e2.x) + abs(e1.y - e2.y)*abs(e1.y - e2.y))+ abs(e1.h-e2.h)*abs(e1.h-e2.h);
}
int find(int x)
{
    return x == pre[x] ? x : find(pre[x]);
}
double kruskal()
{
    iota(pre.begin(),pre.end(),0);
    sort(edge.begin(),edge.end());
    double sum = 0;
    int cnt = 0;
    for(auto &w : edge)
    {
        int nx = find(w.from), ny = find(w.to);
        double c = w.cost;
        if(nx == ny)
            continue;
        
        pre[nx] = ny;
        sum += c;

        if(++cnt == N-1)
            break;
    }
    return cnt == N - 1 ? sum : -1;
}
int main()
{
    cin>>N;
    for(int i = 0;i < N;++i)
    {
        cin>>all[i].x>>all[i].y>>all[i].h;
    }
    for(int i = 0;i < N;++i)
    {
        for(int j = i + 1;j < N;++j)
        {
            double cs = getTotal(all[i],all[j]);
            edge.push_back({i,j,cs});
        }
    }
    double cost = kruskal();
    printf("%.2f\n",cost);
    return 0;
}

```

#### 10.植树

【问题描述】
小明和朋友们一起去郊外植树，他们带了一些在自己实验室精心研究出的小树苗。
小明和朋友们一共有 n 个人，他们经过精心挑选，在一块空地上每个人挑选了一个适合植树的位置，总共 n 个。他们准备把自己带的树苗都植下去。
然而，他们遇到了一个困难：有的树苗比较大，而有的位置挨太近，导致两棵树植下去后会撞在一起。
他们将树看成一个圆，圆心在他们找的位置上。如果两棵树对应的圆相交，这两棵树就不适合同时植下（相切不受影响），称为两棵树冲突。
小明和朋友们决定先合计合计，只将其中的一部分树植下去，保证没有互相冲突的树。他们同时希望这些树所能覆盖的面积和（圆面积和）最大。
【输入格式】
输入的第一行包含一个整数 n ，表示人数，即准备植树的位置数。
接下来 n 行，每行三个整数 x, y, r，表示一棵树在空地上的横、纵坐标和半径。
【输出格式】
输出一行包含一个整数，表示在不冲突下可以植树的面积和。由于每棵树的面积都是圆周率的整数倍，请输出答案除以圆周率后的值（应当是一个整数）。
【样例输入】
6
1 1 2
1 4 2
1 7 2
4 1 2
4 4 2
4 7 2
【样例输出】
12
【评测用例规模与约定】
对于 30% 的评测用例，1 <= n <= 10；
对于 60% 的评测用例，1 <= n <= 20；
对于所有评测用例，1 <= n <= 30，0 <= x, y <= 1000，1 <= r <= 1000。

> > <b>考点：</b>递归，动态规划，深度搜索，剪枝
> >
> > <b>总结:</b>多加练习，重复练习。根据题目的规模，尝试着大体去推出出题人希望用什么规模来解决
> >
> > 每个圆可以选也可以不选，但不知道哪种决策结果最大，只能先考虑暴力搜索每种情况，总可选数为2的n次方的深度优先搜索。
> >
> > 某1个圆在准备选入的时候，可以判断是否与之前已选的圆冲突，如果冲突了，这条分支就可以不继续了，这可以视为剪枝；但是判断是否冲突的check函数要遍历已入选的圆，复杂度依然高；
> >
> > 代码在n等于30的是否时间太长

```c++
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;
struct Tree
{
    int x,y,r;
    bool operator<(const Tree& e)const 
    {
        return r < e.r;
    }
};
int N,ans = 0;
vector<Tree> trees;
int selected[1005];//选择的点标注为1
int adja_table[1005][1005];//邻接矩阵
//两个圆是否相交，相交返回true
bool intersected(Tree a,Tree b)
{
    int dis = (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y);
    return dis < (a.r + b.r)*(a.r + b.r);
}
//对于既定的选择列表，index这个点能否加入
bool ok(int index)
{
    for(int i = 0;i < index;++i)
    {
        //与当前选择的路径上（也就是dfs走过的）的树两两不想交
        if(selected[i] && adja_table[i][index])
        {
            return false;
        }
    }
    return true;
}
void dfs(int sum,int index)
{
    //边界
    if(index == N)
    {
        ans = max(ans,sum);
        return;
    }
    //1.不选当前这棵树
    selected[index] = 0;
    dfs(sum,index + 1);
    //2.选这棵树（是有条件的）
    if(ok(index))
    {
        selected[index] = 1;
        dfs(sum + (trees[index].r)*(trees[index].r),index + 1);
        selected[index] = 0;
    }
}
int main()
{
    cin>>N;
    for(int i = 0;i < N;++i)
    {
        Tree t;
        cin>>t.x>>t.y>>t.r;
        trees.push_back(t);
    }
    //两两组合，看是否交叉，平方级
    for(int i = 0;i < N - 1;++i)
    {
        for(int j = i + 1; j < N;++j)
        {
            if(intersected(trees[i],trees[j]))
            {
                adja_table[i][j] = 1;
                adja_table[j][i] = 1;
            }
        }
    }
    dfs(0,0);
    cout<<ans<<endl;
    return 0;
}
```

><b>优化:</b> 优化的关键点在于用类似贪心的办法（但不是贪心）；将圆按半径从大到小排序，这样悠闲考虑半径大的圆的选与不选问题；另外把“选”这个分支放在“不选”这个分支前面执行，这样我们相信会尽早地遇到最优解。
>
>基于这个假设，在递归之前我们可以以O(n)的复杂度存储所有圆的“半径的平方”的后缀和，计为数组s;在递归函数dfs中，参数sum代表index之前的选择策略所得到的sum，s[index]代表包括index索引及之后续所有圆的半径的平方和，如果sum+s[index]小于等于已经求得的ans，那就不必进行任何后续的选择试探了，可立即退出递归。
>
>测试，代码在n = 30时能秒出结果。

```c++
#include<iostream>
#include<vector>
#include<cmath>
#include<algorithm>
using namespace std;
struct Tree
{
    int x,y,r;
    bool operator<(const Tree& e)const 
    {
        return r < e.r;
    }
};
int N,ans = 0;
vector<Tree> trees;
int selected[1005];//选择的点标注为1
int adja_table[1005][1005];//邻接矩阵
int s[1005];//计算后缀和
//两个圆是否相交，相交返回true
bool intersected(Tree a,Tree b)
{
    int dis = (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y);
    return dis < (a.r + b.r)*(a.r + b.r);
}
//对于既定的选择列表，index这个点能否加入
bool ok(int index)
{
    for(int i = 0;i < index;++i)
    {
        //与当前选择的路径上（也就是dfs走过的）的树两两不想交
        if(selected[i] && adja_table[i][index])
        {
            return false;
        }
    }
    return true;
}
void dfs(int sum,int index)
{
    //边界
    if(index == N)
    {
        ans = max(ans,sum);
        return;
    }
    if(sum + s[index] <= ans)
        return;
    //2.选这棵树（是有条件的）
    if(ok(index))
    {
        selected[index] = 1;
        dfs(sum + (trees[index].r)*(trees[index].r),index + 1);
        selected[index] = 0;
    }
    //1.不选当前这棵树
    selected[index] = 0;
    dfs(sum,index + 1);
}
int main()
{
    cin>>N;
    for(int i = 0;i < N;++i)
    {
        Tree t;
        cin>>t.x>>t.y>>t.r;
        trees.push_back(t);
    }
    sort(trees.begin(),trees.end());
    //开始计算后缀和
    s[N - 1] = (trees[N - 1].r)*(trees[N - 1].r); 
    for(int i = 1;i < N;++i)
    {
        s[N - 1 - i] = s[N-i] + (trees[N - 1- i].r)*(trees[N-1-i].r);
    }
    //两两组合，看是否交叉，平方级
    for(int i = 0;i < N - 1;++i)
    {
        for(int j = i + 1; j < N;++j)
        {
            if(intersected(trees[i],trees[j]))
            {
                adja_table[i][j] = 1;
                adja_table[j][i] = 1;
            }
        }
    }
    dfs(0,0);
    cout<<ans<<endl;
    return 0;
}
```