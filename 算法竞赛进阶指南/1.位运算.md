#1.位运算

---

`-x = ~x + 1` :`~x + 1`是`x`的补码

### **`Acwing 89. a^b`**

> 考点：

```c++
#include<iostream>

using namespace std;

int main()
{
    int a,b,p;
    cin>>a>>b>>p;
    int res = 1%p;//注意b为零的情况
    while(b)
    {
        if(b&1)
            res  = res *1ll * a % p;
            a = a * 1ll * a % p;
            b >>= 1;
    }
    cout<<res<<endl;
    return  0;
}
```

###**`90. 64位整数乘法`**

> 考点：

```c++
#include<iostream>

using namespace std;

typedef unsigned long long ULL;

int main()
{
    ULL a,b,p;
    cin>>a>>b>>p;
    ULL res = 0;
    while(b)
    {
        if(b&1)res = (res + a)%p;
        b >>= 1;
        a = a * 2 % p;
    }
    cout<<res<<endl;
    return 0;
}
```

### **`91. 最短Hamilton路径`**

> 考点：
>
> 总结：
>
> `f[state][j]= f[state_k][k] + weight[k][j],state_k = state除掉j之后的集合。state_k要包含k`
>
> `lowbit`运算： 求出n的数值中最低的一位1是哪个。(计算机中所有的位运算都是O(1)的时间复杂度）
>
> ```c++
> int lowbit(n)
> {
>    // return (~n + 1) & n;
>     return (-n)&n;
> }
> /*1110010000 
> * 0001101111 + 1
> * 0001110000
> * 0000010000
> */
> ```
>
> 

```c++
#include<iostream>
#include<cstring>

using namespace std;

const int N = 20, M = 1 << 20;

int n;
int f[M][N], weight[N][N];

int main()
{
    cin>>n;
    for(int i = 0;i < n;i++)
    {
        for(int j = 0;j < n;j++)
        {
            cin>>weight[i][j];   
        }
    }
    memset(f,0x3f,sizeof(f));
    f[1][0] = 0;
    
    for(int i = 0;i < 1<<n;i++)//状态为i
        for(int j = 0;j < n;j++)
            if(i >> j && 1)
                for(int k = 0;k < n;k++)
                    if(i-(1<<j) >> k & 1)//当前状态减去第j位，第k位是1说明第i状态包含k
                        f[i][j] = min(f[i][j],f[i - (1<<j)][k] + weight[k][j]);
    
    cout<<f[(1<<n) - 1][n - 1]<<endl;
    return 0;
}
```

