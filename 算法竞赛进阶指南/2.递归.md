### 2.递归

---

### 92.递归实现指数型枚举

> 考点：递归，位运算

```c++
#include<iostream>

using namespace std;

int n;

void dfs(int u,int state)
{
    if(u == n)
    {
        for(int i = 0;i < n;++i)
            if(state >> i & 1)
                cout<<(i+1)<<' ';
        cout<<endl;
        return ;
    }
    dfs(u + 1,state);
    dfs(u + 1,state | 1 << u);
}
int main()
{
    cin>>n;
    dfs(0,0);
    return 0;   
}
```

### 93. 递归实现组合型枚举

> 考点：

```c++
#include<iostream>

using namespace std;

int n,m;

void dfs(int u,int sum,int state)
{
    if(sum + n - u < m)return;
    if(sum == m)
    {
        for(int i = 0;i < n;++i)
            if(state >> i & 1)
                cout<<i+ 1<<' ';
        cout<<endl;
        return;
    }
    
    if(u == n)return;
    
    dfs(u + 1,sum + 1,state | 1 << u);
    dfs(u + 1,sum,state);
}
int main()
{
    cin>>n>>m;
    dfs(0,0,0);
    return 0;
}
```

> **思考题**：如果要求使用非递归方法，该怎么做呢？

```c++
#include<iostream>
#include<stack>

using namespace std;

int n,m;

struct State
{
    int pos,u,sum,state;
};

void dfs(int u,int sum,int state)
{
    //0
    if(sum + n - u < m)return ;
    if(sum == m)
    {
        for(int i = 0;i < n;i++)
            if(state >> i & 1)
                cout<<i + 1<<' ';
        cout<<endl;
        return;
    }
    dfs(u + 1,sum + 1,state | 1<<u);

    //1
    dfs(u + 1,sum,state);

    //2
}

int main()
{
    cin>>n>>m;
    
    stack<State> stk;
    stk.push({0,0,0,0});
    
    while (stk.size())
    {
        auto t = stk.top();
        stk.pop();

        if(t.pos == 0)
        {
            if(t.sum + n - t.u < m)continue;
            if(t.sum == m)
            {
                for(int i = 0;i < n;i++)
                    if(t.state >> i & 1)
                        cout<<i + 1<<' ';
                cout<<endl;
                continue;
            }

            t.pos = 1;
            stk.push(t);
            stk.push({0,t.u + 1,t.sum + 1,t.state | 1 << t.u});
        }
        else if(t.pos == 1)
        {
            t.pos = 2;
            stk.push(t);
            stk.push({0,t.u + 1,t.sum,t.state});
        }
        else continue;
    }
    

    return 0;
}


```



### 94. 递归实现排列型枚举

> 考点：

```c++
#include<iostream>
#include<vector>

using namespace std;

int n;
vector<int> path;

void dfs(int u,int state)
{
    if(u == n)
    {
        for(auto x : path)cout<<x<<' ';
        cout<<endl;
        return ;
    }
    
    for(int i = 0;i < n;++i)
        if(!(state >> i & 1))
        {
            path.push_back(i + 1);
            dfs(u + 1,state | (1 << i));
            path.pop_back();
        }
}

int main()
{
    cin>>n;
    dfs(0,0);
    return 0;
}
```

### 95. 费解的开关

> 考点：

```c++
#include<iostream>
#include<cstring>

using namespace std;

const int INF = 1000000;//1百万

char g[10][10];//注意：这里按灯的时候是对其进行操作的（也就是操作过程中该数组为变值）
int dx[5] = {0,-1,0,1,0},dy[5] = {0,0,1,0,-1};//中间，上，右，下，左

void turn(int x,int y)
{
    for(int i = 0;i < 5;i++)
    {
        int a = x + dx[i], b = y + dy[i];
        if(a >= 0 && a < 5 && b >= 0 && b < 5)
        {
            g[a][b] ^= 1;// 不同为1 相同为0
        }
    }
}
int work()
{
    int ans = INF;
    for(int k = 0;k < 1<<5;k++)//枚举第一行的开关
    {
        int res = 0;
        char backup[10][10];//测试数组
        memcpy(backup,g,sizeof(g));//复制
        for(int j = 0;j < 5;j++)//第一行开关按下的操作（k的每一位对应是否按下）
            if(k >> j & 1)
            {
                res++;
                turn(0,j);
            }
        
        for(int i = 0;i < 4;i++)//对第一行下面的四行灯进行操作（第五行不用按（保证全部打开））
            for(int j = 0;j < 5;j++)//每行按照上一行的操作进行按键
                if(g[i][j] == '0')
                {
                    res++;
                    turn(i + 1,j);
                }
        
        bool is_successful = true;
        for(int j = 0;j < 5;j++)//判断最后一行灯是否都打开
            if(g[4][j] == '0')
            {
                is_successful = false;
                break;
            }
            
        if(is_successful)ans = min(ans,res);
        
        memcpy(g,backup,sizeof(g));//将测试数还原，进行下一次枚举(赋值backup数组是因为按灯的操作是在g数组中进行的)
    }
    
    if(ans > 6)ans = -1;
    return ans;
}

int main()
{
    int T;
    cin>>T;
    while(T--)
    {
        for(int i = 0;i < 5;i++)cin>>g[i];
        
        cout<<work()<<endl;
    }
    return 0;
}
```

### 96. 奇怪的汉诺塔

> 考点：



```c++
#include<iostream>
#include<cstring>

using namespace std;

int main()
{
    int d[15], f[15];

    d[1] = 1;
    for(int i = 2;i <= 12;i++)
    {
        d[i] = 1 + d[i - 1] * 2;
    }

    memset(f,0x3f,sizeof(f));
    f[0] = 0;
    for(int i = 1;i <= 12;i++)
        for(int j = 0;j < i;j++)
            f[i] = min(f[i],f[j] * 2 + d[i - j]);
    for(int i = 1;i <= 12;i++)cout<<f[i]<<endl;
    return 0;
}
```

### 97. 约数之和

> 考点：



```c++
#include<iostream>
#include<cstring>

using namespace std;

const int mod = 9901;

int qmi(int a,int k)
{
    a %= mod;
    int res = 1;
    while(k)
    {
        if(k&1)res = res * a % mod;
        a = a * a % mod;
        k >>= 1;
    }
    return res;
}

int sum(int p,int k)
{
    if(k == 0)return 1;
    if(k % 2 == 0)return (p % mod * sum(p,k - 1) + 1) % mod;
    return (1 + qmi(p, k/2 + 1)) * sum(p,k / 2) % mod;
}

int main()
{
    int A,B;
    cin>>A>>B;
    int res = 1;
    for(int i = 2;i <= A;i++)
    {
        int s = 0;
        while(A % i == 0)
        {
            s++;
            A /= i;
        }
        if(s)res = res * sum(i,s * B) % mod;
    }
    if(!A)res = 0;
    cout<<res<<endl;
    return 0;
}
```

### 98. 分形之城

> 考点：递归,坐标变换（注意数据范围）
>
> 总结：坐标顺时针旋转 $\theta$ ：
>
> $ \begin{pmatrix} x & y \end{pmatrix} $$ \begin{pmatrix}  \cos \theta&\sin \theta  \\ {-}\sin \theta &\cos \theta \\ \end{pmatrix}$
>
>  向量旋转(对应的矩阵相乘 )**左下角的坐标变换（首先要明白旋转点所在的位置（每个城市占据一个数组元素空间））：坐标整体顺时针旋转270度（逆时针旋转90度），然后进行移动操作（比较 难以理解的一点） 首先整体向右移动len - 1个位置 (-y,len - 1 - x)(len - 1个单位是因为旋转点在1的位置，所以要减去1)，同理整体向下移动2*len - 1个位置.坐标变为(2*len - 1 - y,len - 1 - x)(2*len - 1个单位是因为旋转点占据了一个位置，所以要减去1)。而对于右上角和右下角只是简单的移动不涉及旋转点城市所占据的位置，这两个位置只是将整个块平移而已，左下角的块得到的过程移动是以旋转点（单个城市）为参考点，而右上角和右下角移动是以整个块(小一级的城市区域)为参考点。**
>
> 向量旋转(对应的矩阵相乘 )

```c++
#include<iostream>
#include<cmath>

using namespace std;

typedef long long LL;
typedef pair<LL,LL> PLL;

PLL calc(LL n,LL m)
{
    if(n == 0)return {0,0};
    LL len = 1ll << n - 1,cnt  = 1ll << 2*n - 2;
    auto pos = calc(n - 1,m % cnt);
    auto x = pos.first,y = pos.second;
    auto z = m / cnt;
    if(z == 0)return {y,x};
    if(z == 1)return {x,y + len};
    if(z == 2)return {x + len,y + len};
    return {2 * len - 1 - y,len - 1 - x};
}

int main()
{
    int T;
    cin>>T;
    while(T--)
    {
        LL N,A,B;
        cin>>N>>A>>B;
        auto ac = calc(N,A - 1);
        auto bc = calc(N,B - 1);
        double x = ac.first - bc.first, y = ac.second - bc.second;
        printf("%.0lf\n",sqrt(x * x + y * y) * 10);
    }
    return 0;
}
```

