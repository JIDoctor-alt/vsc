###贪心算法

###  `Acwing 110.防晒`

> 匈牙利算法、`upper_bound`返回小于等于指定值的最大值

```c++
#include<iostream>
#include<cstring>
#include<map>
#include<algorithm>

using namespace std;

typedef pair<int,int> PII;
const int N = 2510;

int n,m;
PII cows[N];

int main()
{
    cin>>n>>m;
    map<int,int> spfs;

    for(int i = 0;i < n;i++)cin>>cows[i].first>>cows[i].second;
    for(int i = 0;i < m;i++)
    {
        int spf,cover;
        cin>>spf>>cover;
        spfs[spf] += cover;//注意这里要写 += ，因为数据中存在spf值相同的防晒霜
    }
    sort(cows,cows + n);
    int res = 0;
    spfs[0] = spfs[1001] = n;
    for(int i = n - 1;i >= 0;i--)
    {
        auto spf = spfs.upper_bound(cows[i].second);
        spf--;
        if(spf->first >= cows[i].first)
        {
            res++;
            if(--spf->second == 0)
                spfs.erase(spf);
        }
    }
    cout<<res<<endl;
    return 0;
}

```

### `Acwing 111. 畜栏预定`

>优先队列

```c++
#include<iostream>
#include<cstring>
#include<queue>
#include<vector>
#include<algorithm>

using namespace std;

typedef pair<int,int> PII;
const int N = 50010;

int n;
int id[N];
pair<PII,int> cows[N];

int main()
{
    cin>>n;
    for(int i = 0;i < n;i++)
    {
        cin>>cows[i].first.first>>cows[i].first.second;
        cows[i].second = i;
    }

    sort(cows,cows + n);

    priority_queue<PII,vector<PII>,greater<PII> > heap;
    for(int i = 0;i < n;i++)
    {
        if(heap.empty() || heap.top().first >= cows[i].first.first)
        {
            PII stall = {cows[i].first.second,heap.size()};
            id[cows[i].second] = stall.second;
            heap.push(stall);
        }
        else 
        {
            auto stall = heap.top();
            heap.pop();
            stall.first = cows[i].first.second;
            id[cows[i].second] = stall.second;
            heap.push(stall);
        }
    }

    cout<<heap.size()<<endl;
    for(int i = 0;i < n;i++)cout<<id[i] + 1<<endl;
    return 0;
}
```

###`Acwing 112. 雷达设备`

>勾股定理	

```c++
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>

using namespace std;

typedef pair<double,double> PDD;
const int N = 1010;
const double  eps = 1e-6,INF = 1e10;

int n,d;
PDD seg[N];

int main()
{
    cin>>n>>d;

    bool success = true;

    for(int i = 0;i < n;i++)
    {
        int x,y;
        cin>>x>>y;
        if(y > d)
        {
            success = false;
        }
        auto len = sqrt(d*d - y * y);
        seg[i] = {x + len,x - len};
    }

    if(!success)puts("-1");
    else
    {
        sort(seg,seg + n);
        int res = 0;
        double last = -INF;
        for(int i = 0;i < n;i++)
        {
            if(seg[i].second > last + eps)
            {
                res++;
                last = seg[i].first;
            }
        }
        cout<<res<<endl;
    }
    return 0;
}
```

### `Acwing 114. 国王游戏`

>

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>

using namespace std;

typedef pair<int,int> PII;
const int N = 1010;

int n;
PII p[N];

vector<int> mul(vector<int> a,int b)
{
    vector<int> c;
    int t = 0;
    for(int i= 0;i < a.size();i++)
    {
        t += a[i] * b;
        c.push_back(t%10);
        t /= 10;
    }
    while(t)
    {
        c.push_back(t%10);
        t /= 10;
    }
    return c;
}

vector<int> div(vector<int> a,int b)
{
    vector<int> c;
    bool is_first = true;
    for(int i = a.size() - 1,t = 0;i >= 0;i--)
    {
        t = t * 10 + a[i];
        int x = t / b;
        if(!is_first || x)
        {
            is_first = false;
            c.push_back(x);
        }
        t %= b;
    }
    reverse(c.begin(),c.end());
    return c;
}
vector<int> max_vec(vector<int> a,vector<int> b)
{
    if(a.size() > b.size()) return a;
    if(a.size() < b.size()) return b;
    if(vector<int>(a.rbegin(),a.rend()) > vector<int>(b.rbegin(),b.rend()))return a;
    return b;
}
int main()
{
    cin>>n;
    for(int i = 0;i <= n;i++)
    {
        int a,b;
        cin>>a>>b;
        p[i] = {a*b,a};
    }
    sort(p + 1,p + n + 1);
    vector<int> product(1,1);

    vector<int> res(1,0);
    for(int i = 0;i <= n;i++)
    {
        if(i)res = max_vec(res,div(product,p[i].first/p[i].second));
        product = mul(product,p[i].second);
    }

    for(int i = res.size() - 1;i >= 0;i--)cout<<res[i];
    cout<<endl;
    return 0;
}
```

###`Acwing 115. 给树染色`

>
>
>

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 1010;

int n,root;
struct Node
{
    int p,s,v;
    double avg;
}nodes[N];

int  find()
{
    double avg = 0;
    int res = -1;
    for(int i = 1;i <= n;i++)
        if(i != root && nodes[i].avg > avg)
        {
            avg = nodes[i].avg;
            res = i;
        }
    return res;
}
int main()
{
    cin>>n>>root;
    int ans = 0;
    for(int i = 1;i <= n;i++)
    {
        cin>>nodes[i].v;
        nodes[i].avg = nodes[i].v;
        nodes[i].s = 1;
        ans += nodes[i].v;
    }
    for(int i = 0;i < n - 1;i++)
    {
        int a,b;
        cin>>a>>b;
        nodes[b].p = a;
    }

    for(int i = 0;i <n - 1;i++)
    {
        int p = find();
        int father = nodes[p].p;
        ans += nodes[p].v * nodes[father].s;
        nodes[p].avg = -1;
        for(int j = 1;j <= n;j++)
            if(nodes[j].p == p)
                nodes[j].p = father;
        
        nodes[father].v += nodes[p].v;
        nodes[father].s += nodes[p].s;
        nodes[father].avg = (double)nodes[father].v/nodes[father].s;
    }

    cout<<ans<<endl;
    return 0;
}
```

