### ***3.前缀和与差分***

---

###99. 激光炸弹

> 考点：
>
> 总结：考虑矩形范围的前缀和。

```c++
#include<iostream>
#include<cstring>

using namespace std;

const int N = 5005;

int g[N][N];
int main()
{
    int N,R;
    cin>>N>>R;
    int n = R, m = R;
    for(int i = 0,x,y,w;i < N;++i)
    {
        cin>>x>>y>>w;
        x++,y++;//定义为下标从1开始计算
        n = max(n,x), m = max(m,y);
        g[x][y] += w;//不同的目标可能在同一个位置
    }
    
    for(int i = 1;i <= n;i++)
    {
        for(int j = 1;j <= m;j++)
        {
            g[i][j] += g[i][j - 1] + g[i - 1][j] - g[i-1][j-1];//计算前缀和
        }
    }
    
    int res = 0;
    for(int i = R;i <= n;i++)
        for(int j = R;j <= m;j++)
            res = max(res,g[i][j] - g[i][j - R] - g[i-R][j] + g[i - R][j - R]);//注意这里算的是R-1的矩形（根据爆炸范围）
            //若目标在爆炸正方形的边上则不会被摧毁
    cout<<res<<endl;
    return 0;
}
```

### 100. 增减序列

> 考点：差分序列

```c++
/*

a[1],a[2],....,a[n]

b[i] = a[i] - a[i-1],b[1] = a[1]

a[i] = b[1] + b[2] + ... + b[i]
     = a[1] + a[2] - a[1] + a[3] - a[2] + ... + a[i] - a[i-1]

给区间[l,r]加上一个常数C

b[l] += C , b[r + 1] -= C

1. 2 <= i ,j <= n
2. i = 1,2 <= j <= n
3. 2 <= i <= n,j = n + 1
4. i = 1,j = n + 1

*/

#include<iostream>
#include<algorithm>

using namespace std;

typedef long long LL;

const int N = 100010;

int a[N];

int main()
{
    int n;
    cin>>n;
    for(int i = 1;i <= n;i++)cin>>a[i];
    for(int i = n;i > 1;i--)a[i] -= a[i-1];
    
    LL pos = 0,neg = 0;
    for(int i = 2;i <= n;i++)
        if(a[i] > 0)pos += a[i];
        else neg -= a[i];
    
    cout<<min(pos,neg) + abs(pos - neg)<<endl;
    cout<<abs(pos - neg) + 1<<endl;
    return 0;
}
```

### 101. 最高的牛

> 考点：差分

```c++
#include<iostream>
#include<set>

using namespace std;

const int  N = 10010;

int height[N];


int main()
{
    int n,p,h,m;
    cin>>n>>p>>h>>m;
    height[1] = h;
    set<pair<int,int> > existed;
    for(int i = 0,a,b; i < m;i++)
    {
        cin>>a>>b;
        if(a > b)swap(a,b);
        if(!existed.count({a,b}))//牛的位置可能重合
        {
            existed.insert({a,b});
            height[a + 1]--,height[b]++;
        }
    }
    
    for(int i = 1;i <= n;i++)
    {
        height[i] += height[i - 1];
        cout<<height[i]<<endl;
    }
    
    return 0;
}
```

