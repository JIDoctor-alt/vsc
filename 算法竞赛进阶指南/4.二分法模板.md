###二分法模板

---

二分模板一共有两个，分别适用于不同情况。

算法思路：假设目标值在闭区间`[l,r]`中，每次将区间长度缩小一半，当`l = r`时，我们就找到了目标值。

#### 版本1

> 当我们将区间`[l,r]`划分成`[l,mid]`和`[mid + 1,r]`时，其更新操作是`r = mid`或者`l = mid + 1;`，计算`mid`时不需要加1。

```c++
int bsearch_1(int l,int r)
{
    while(l < r)
    {
        int mid = l + r >> 1;
        if(check(mid))r = mid;
        else l = mid + 1;
    }
    return l;
}
```

#### 版本2

> 当我们将区间`[l,r]`划分成`[l,mid - 1]`和`[mid , r]`时，其更新操作是`r = mid - 1`或者`l = mid;`，此时为了防止死循环，计算`mid`时需要加1。

```c++
int  bsearch_2(int l,int r)
{
    while(l < r)
    {
        int mid = l + r + 1 >> 1;
        if(check(mid))l = mid;
        else r = mid - 1;
    }
    return l;
}
```

### 102. 最佳牛围栏

> 考点：
>
> 总结：注意：围起区域内至少需要包含 F 块地，其中 F会在输入中给出。使得围起来的区域内每块地包含的牛的数量的平均值达到最大。

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 100010;

int n,m;
int cows[N];
double sum[N];

bool check(double avg)
{
    for(int i = 1;i <= n;i++)
        sum[i] = sum[i-1] + cows[i] - avg;
    
    double minv = 0;
    for(int i = 0,j = m;j <= n;j++,i++)
    {
        minv = min(minv,sum[i]);
        if(sum[j] >= minv)//存在这个区域
            return true;
    }
    return false;
}
int main()
{
    cin>>n>>m;
    for(int i = 1;i <= n;i++)
        cin>>cows[i];
    double l = 0, r = 2000;
    while(r - l > 1e-5)
    {
        double mid = (l + r)/2;
        if(check(mid))
            l = mid;
        else 
            r = mid;
    }
    printf("%d\n",int(r * 1000));
    return 0;
}
```

### 113. 特殊排序

> 考点：
>
> 总结：

```c++
// Forward declaration of compare API.
// bool compare(int a, int b);
// return bool means whether a is less than b.

class Solution {
public:
    vector<int> specialSort(int N) {
        vector<int> res;
        res.push_back(1);
        for(int i = 2;i <= N;i++)
        {
            int  l = 0, r = res.size() - 1;
            while(l < r)
            {
                int mid = l + r + 1 >> 1;
                if(compare(res[mid],i))
                    l = mid;
                else 
                    r = mid - 1;
            }
            res.push_back(i);
            for(int j = res.size() - 2;j > r;j--)
                swap(res[j],res[j + 1]);
            if(compare(i,res[r]))
                swap(res[r],res[r + 1]);
        }
        return res;
    }
};
```

