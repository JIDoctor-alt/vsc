### 底层注解`@Import`导入组件

> `MyConfig`类

```java
package com.atguigu.boot.config;

import ch.qos.logback.core.db.DBHelper;
import com.atguigu.boot.bean.Pet;
import com.atguigu.boot.bean.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
/*
* 1、配置类（默认也是一个组件）里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的
* 2、配置类本身也是组件
* 3、proxyBeanMethods : 代理bean的方法
*   全配置、
*   Full(proxyBeanMethods = true)【保证每个@Bean方法被调用多多少次返回的组件都是单实例的】
*   轻量级配置、
*   Lite(proxyBeanMethods = false)【每个@Bean方法被调用多少次返回的组件都是新创建的
*   组件依赖必须使用Full模式摩恩。其他默认是否Lite模式
* 4、@Import({User.class, DBHelper.class})
*       给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名
* */

@Import({User.class, DBHelper.class})
@Configuration(proxyBeanMethods = true)//告诉SpringBoot这是一个配置类 == 配置文件
public class MyConfig {
    /*
    * 外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象
    * */
    @Bean//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例
    public User user01(){
        User zhangsan =  new User("zhangsan",18);
        //user组件依赖了Pet组件
        zhangsan.setPet(tomcatPet());
        return zhangsan;
    }

    @Bean("tom")//自定义一个组件名，之后就不是方法名了
    public Pet tomcatPet(){
        return new Pet("tomcat");
    }
}

```

> `MainApplication`类

```jav
 //5、获取组件
        String[] beanNamesForType = run.getBeanNamesForType(User.class);
        System.out.println("==========");
        for (String s : beanNamesForType){
            System.out.println(s);
        }

        DBHelper bean1 = run.getBean(DBHelper.class);
        System.out.println(bean1);
```

###底层注解`@Conditional`条件装配

> 案例演示：`@ConditionalOnBean(name = "tom")`和`@ConditionalOnMissingBean(name = "tom")`对比

>`MyConfig`类

```java

@Import({User.class, DBHelper.class})
@Configuration(proxyBeanMethods = false)//告诉SpringBoot这是一个配置类 == 配置文件
//@ConditionalOnBean(name = "tom")
@ConditionalOnMissingBean(name = "tom")
public class MyConfig {
    /*
    * 外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象
    * */

    @Bean//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例
    public User user01(){
        User zhangsan =  new User("zhangsan",18);
        //user组件依赖了Pet组件
        zhangsan.setPet(tomcatPet());
        return zhangsan;
    }

    @Bean("tom22")//自定义一个组件名，之后就不是方法名了
    public Pet tomcatPet(){
        return new Pet("tomcat");
    }
}
```

> 主配置类`MainApplication`

```java
      //tom组件是否存在

        boolean tom = run.containsBean("tom");
        System.out.println("容器中Tom组件："+tom);

        boolean user01 = run.containsBean("user01");
        System.out.println("容器中user01组件："+user01);

        boolean tom22 = run.containsBean("tom22");
        System.out.println("容器中user01组件："+tom22);
```

###底层注解`@ImportResource("classpath:beans.xml")`导入`Spring`配置文件

> `beans.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

    <bean id="haha" class="com.atguigu.boot.bean.User">
        <property name="name" value="zhangsan"></property>
        <property name="age" value="18"></property>
    </bean>

    <bean id="hehe" class="com.atguigu.boot.bean.Pet">
        <property name="name" value="tomcat"></property>
    </bean>
</beans>
```

>`MyConfig`配置类

```java
@ImportResource("classpath:beans.xml")
public class MyConfig {
    /*
  
```

### 底层注解`@ConfigurationProperties`配置绑定

> - `@Component + @ConfigurationProperties`

```java
package com.atguigu.boot.bean;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;
/*
* 只有在容器中的组件，才会拥有SpringBoot提供的强大功能
* */
@Component
@ConfigurationProperties(prefix = "mycar")
public class Car {


```

> `@EnableConfigurationProperties` +` @ConfigurationProperties`

- 控制类

```java
@EnableConfigurationProperties(Car.class)
//1、开启car配置绑定功能
//2、把这个car这个组件自动注册到容器中
public class MyConfig {
 
    /*
```

- 组件

```java
//@Component
@ConfigurationProperties(prefix = "mycar")
public class Car {

```

- 

```java

/*@ResponseBody//需要以字符串的方式返回给浏览器
//映射一个hello请求
//标注一个请求
@Controller*/
@RestController//就是以上两种映射的合体
public class HelloController {

    @Autowired//自动注入
    Car car;

    @RequestMapping("/car")
    public  Car car(){
        return  car;
    }
    @RequestMapping("/hello")
    public String handle01(){
        return "Hello,Spring Boot 2!";//处理
    }
}

```



---

###**了解自动配置原理**

>1.1、依赖管理

- 父项目做依赖管理

```xml
依赖管理    
<parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.3.4.RELEASE</version>
</parent>

他的父项目
 <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.3.4.RELEASE</version>
  </parent>

几乎声明了所有开发中常用的依赖的版本号,自动版本仲裁机制
```

- 开发导入starter场景启动器

```xml
1、见到很多 spring-boot-starter-* ： *就某种场景
2、只要引入starter，这个场景的所有常规需要的依赖我们都自动引入
3、SpringBoot所有支持的场景
https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter
4、见到的  *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。
5、所有场景启动器最底层的依赖
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter</artifactId>
  <version>2.3.4.RELEASE</version>
  <scope>compile</scope>
</dependency>
```

- 无需关注版本号，自动版本仲裁

```xml
1、引入依赖默认都可以不写版本
2、引入非版本仲裁的jar，要写版本号。
```

- 可以修改默认版本号

```xml
1、查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。
2、在当前项目里面重写配置
    <properties>
        <mysql.version>5.1.43</mysql.version>
    </properties>
```

> 1.2、自动配置

- 自动配好Tomcat

- - 引入Tomcat依赖。
  - 配置Tomcat

```xml
<dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-tomcat</artifactId>
      <version>2.3.4.RELEASE</version>
      <scope>compile</scope>
    </dependency>
```

> - 自动配好`SpringMVC`
>
> - - 引入`SpringMVC`全套组件
>   - 自动配好`SpringMVC`常用组件（功能）
>
> - 自动配好Web常见功能，如：字符编码问题
>
> - - `SpringBoot`帮我们配置好了所有web开发的常见场景
>
> - 默认的包结构
>
> - - 主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来
>   - 无需以前的包扫描配置
>   - 想要改变扫描路径，`@SpringBootApplication(scanBasePackages=**"com.atguigu"**)`
>
> - - - 或者`@ComponentScan` 指定扫描路径

```xml
@SpringBootApplication
等同于
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan("com.atguigu.boot")
```

>
>
>- 各种配置拥有默认值
>
>- - 默认配置最终都是映射到某个类上，如：`MultipartProperties`
>  - 配置文件的值最终会绑定每个类上，这个类会在容器中创建对象
>
>- 按需加载所有自动配置项
>
>- - 非常多的`starter`
>  - 引入了哪些场景这个场景的自动配置才会开启
>  - `SpringBoot`所有的自动配置功能都在 `spring-boot-autoconfigure` 包里面
>  - 
>
>- ......

### 自动包规则原理

###初始加载配置类

###自动配置流程

### Lombok

> 简化`JavaBean开发`

- `HelloController`

```java
package com.atguigu.boot.controller;


import com.atguigu.boot.bean.Car;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/*@ResponseBody//需要以字符串的方式返回给浏览器
//映射一个hello请求
//标注一个请求
@Controller*/
@Slf4j//自动注入日志类
@RestController//就是以上两种映射的合体
public class HelloController {

    @Autowired//自动注入
    Car car;

    @RequestMapping("/car")
    public  Car car(){
        return  car;
    }
    @RequestMapping("/hello")
    public String handle01(){

        log.info("请求进来了。。。。");
        return "Hello,Spring Boot 2!";//处理
    }
}

```

- `Car`

```java
package com.atguigu.boot.bean;

import lombok.Data;
import lombok.ToString;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;
/*
* 只有在容器中的组件，才会拥有SpringBoot提供的强大功能
* */
//@Component
@ToString//在编译类的时候自动生成tostring方法
@Data//帮助生成已有属性的get和set方法
@ConfigurationProperties(prefix = "mycar")
public class Car {

    private String brand;
    private Integer price;

}

```

- `Pet`

```java
package com.atguigu.boot.bean;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

/*宠物*/
@ToString
@Data
@NoArgsConstructor//无参构造器
@AllArgsConstructor//自动构造全参构造器
public class Pet {

    private String name;


    @Override
    public String toString() {
        return "Pet{" +
                "name='" + name + '\'' +
                '}';
    }
}

```

- `User`

```java
package com.atguigu.boot.bean;

import lombok.*;

/*
用户
* */
@NoArgsConstructor
//@AllArgsConstructor
@Data
@ToString
@EqualsAndHashCode
public class User {

    private String name;
    private Integer age;

    private  Pet pet;

    public User(String name,Integer age){
        this.name = name;
        this.age = age;
    }
}

```

###4.2、dev-tools

```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <optional>true</optional>
        </dependency>
```

`项目或者页面修改以后：Ctrl+F9`

