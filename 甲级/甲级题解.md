### **1015** **Reversible Primes** 

总结 ：素数判断（打印素数表），进制逆转（用while循环实现）

```c++
#include<iostream>
using namespace std;
int n,d,nonprime[100010];
int getreverse(int n,int d)
{
    int s  = 0;
    while(n != 0)
    {
        s = s * d + (n % d);
        n /= d;
    }
    return s;
}

int main()
{
    for(int i = 2;i * i < 100010;++i)
    {
        for(int j = 2;j * i < 100010;++j)
            nonprime[i * j] = 1;
    }
    nonprime[0] = nonprime[1] = 1;
    while(true)
    {
        scanf("%d",&n);
        if(n < 0)
            break;
        scanf("%d",&d);
        if(nonprime[n] || nonprime[getreverse(n,d)])
            cout<<"No\n";
        else 
            cout<<"Yes\n";
    }
    return 0;
}
```

### 1016   **Phone Bills**

<b>考点：</b> 排序

<b>总结 ：</b> 设置容器的时候，注意排序过程中的范围 ：  如果部分没有存入数据会出现排序混乱

```c++
	sort(data.begin(),data.end(),cmp);//这个范围是data[0] 到 data[N-1]
```

注意：scanf输入时要加入地址符& 。

排序是按照名字的字典顺序，时间的先后进行

设计到对事件的计算（这里我按照分钟为单位）

```c++
#include<iostream>
#include<map>
#include<string>
#include<vector>
#include<algorithm>
using namespace std;
struct node
{
    string name;
    int time;
    int mouth,day,hour,minute;
    int status;
    bool operator<(const node &e)const 
    {
        if(name != e.name)
            return name < e.name;
        else 
            return time < e.time;
    }
};
int N;
vector<int> rate(25,0);
vector<node> records; 
double bill(node &re)
{
    double total = rate[re.hour]*re.minute + rate[24]*re.day*60;
    
    for(int i = 0;i < re.hour;++i)
    {
        total += rate[i]*60;
    }

    return total/100.0;
}
int main()
{
    for(int i = 0;i < 24;++i)
    {
        cin>>rate[i];

        rate[24] += rate[i];
    }
    cin>>N;
    records.resize(N);
 //   cout<<"--------------------------\n";
    for(int i = 0;i < N;++i)
    {
        cin>>records[i].name;

        scanf("%d:%d:%d:%d",&records[i].mouth,&records[i].day,&records[i].hour,&records[i].minute);
        //cout<<"------------------\n";
        string isOnline;
        cin>>isOnline;

        records[i].status = (isOnline == "on-line" ? 1 : 0);

        records[i].time = records[i].day*24*60 + records[i].hour*60 + records[i].minute;
     //   cout<<"=========ss========\n";
    }


   // cout<<"=============sort====\n";
    sort(records.begin(),records.end());
    map<string,vector<node> > anw;
//利用map存储每个人对应的通话对数
    for(int i = 1;i < N;++i)
    {
        if(records[i].name == records[i - 1].name && records[i-1].status == 1 && records[i].status == 0)
        {
            anw[records[i-1].name].push_back(records[i-1]);
            anw[records[i].name].push_back(records[i]);
        }    
    }

    double total = 0;

    for(auto &it : anw)
    {
        
        //名字 账单月份
        cout<<it.first;
        vector<node> toll = it.second;
       /// cout<<" "<<toll[0].mouth<<endl;
        printf(" %02d\n",toll[0].mouth);
        total = 0;
        for(int i = 1;i < toll.size();i += 2)
        {
            double pert = bill(toll[i]) - bill(toll[i-1]);
            
            //打印开始和结束日期（dd:HH:mm) 持续时间（分钟） 通话费用
            printf("%02d:%02d:%02d %02d:%02d:%02d %d $%.2f\n",toll[i-1].day,toll[i-1].hour,toll[i-1].minute,toll[i].day,toll[i].hour,toll[i].minute,toll[i].time - toll[i-1].time,pert);
            total += pert;
        }

        printf("Total amount: $%.2f\n",total);
    }

    return 0;

}

```

### **1017** **Queueing at Bank** 

考点： 排队，单位的换算。

总结：优先队列，排队是先来先服务的原则。每个客户给定的服务时间以分钟为单位，这里需要全部换算成秒。

优先队列用于存储客户最早完成的时间。队列初始的时间全部设置为8点，每次来一个客户，与队首元素进行比较。如果最早完成的小于等于 当前入队的新用户 ，直接将该新客户的完成时间入队，并且队首元素出队（也就是走掉一个客户）；如果最早完成的大于 当前入队的新用户 则出现等待现象（等待时间为 队首元素即最早完成时间 - 当前用户到来的时间），该客户的完成时间为 队首元素的最早完成时间 + 客户的服务时间,即该新客户的完成时间入队，队首元素出队（走掉一个客户）。依次循环遍历所有用户入队。

```c++
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
struct  Peo
{
    int cost;
    int arriveTime;
    bool operator<(const Peo &e)const
    {
        return arriveTime < e.arriveTime;
    }
}p[10005];
/*bool cmp(Peo &e1,Peo &e2)
{
    return e1.arriveTime < e2.arriveTime;
}*/
int N,K,cnt , total;
int main()
{
    cin>>N>>K;
    for(int i = 1;i <= N;++i)
    {
        int hh,mm,ss,l;
        scanf("%d:%d:%d %d",&hh,&mm,&ss,&l);

        int sum = hh * 60 * 60 + mm * 60 + ss;

        if(sum > 17*60*60)
            continue;

        p[++cnt].cost = l*60;//注意l是以分钟为单位
        p[cnt].arriveTime = sum;
    }

    //sort(p + 1, p + cnt + 1,cmp);
    sort(p + 1, p + cnt + 1);
    priority_queue<int,vector<int>,greater<int> > pq;

    for(int i = 1;i <= K;++i)
        pq.push(8*60*60);

    for(int i = 1;i <= cnt;++i)
    {
        if(pq.top() <= p[i].arriveTime)
        { 
            pq.push(p[i].arriveTime + p[i].cost);
            pq.pop();
        }
        else 
        {
            int topTime = pq.top();
            total += topTime - p[i].arriveTime;
            pq.push(p[i].cost + topTime);
            pq.pop();
        }
    }

    (!cnt) ? printf("0.0\n")  : printf("%.1f\n",((double)total/60)/cnt);


    return 0;
}
```



### **1019** General Palindromic Number

考点： 进制转换，数值逆转

```c
#include<iostream>
#include<algorithm>
#include<vector>
#include<string>
using namespace std;
vector<int> toPalindromic(int number,int base)
{
    vector<int> list;
    if(number == 0)
    {
        list.push_back(0);
        return list;
    }

    while(number != 0)
    {
        int bit = number % base;
        list.push_back(bit);
        number /= base;
    }
    return list;
}
bool isPalindromic(vector<int> list)
{
    int length = list.size();
    for(int i = 0,j = length - 1;i < length/2;i++,j--)
    {
        if(list[i] != list[j])
            return false;
    }
    return true;
}
int main()
{
    int number,base;
    cin>>number>>base;
    vector<int> builder = toPalindromic(number,base);
    cout<<(isPalindromic(builder) ? "Yes\n" : "No\n");
    for(int i = builder.size() - 1;i >= 0;i--)
        printf("%d%s",builder[i],i== 0 ? "\n" : " ");
    
    return 0;

}
```

### **1020** Tree Traversals

考点：二叉树的遍历

1. 总结：根据二叉树的后序遍历和中序遍历，推出二叉树的层序遍历。注意在递归过程中，左子树与右子树的长度是不同的。


在允许范围内都要对进行层序遍历以保证值的存储

```c++
 if(s > e)//等于不行（等于的时候也要分配
        return;
```

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
//后序 和 中序
int postorder[10005],inorder[10005];
int level[10005];
int N;
void solve(int root,int s,int e,int index)
{
    if(s > e)//等于不行（等于的时候也要分配
        return;


    int x = postorder[root];

    level[index] = x;
    //cout<<"level------------------"<<level[index]<<endl;

    int i = s;
    //0-1 1-2 2-3 3-4

    while(i < e && inorder[i] != x)
        ++i;

    int l = i - s;
   // cout<<"i-----------"<<i<<"-----x--"<<inorder[i]<<endl;
    //cout<<"left-------"<<postorder[root - l - 1]<<"right--------------"<<postorder[root - 1]<<endl;    
    //e - i 才是右子树的长度
    solve(root - (e - i) - 1, s , i-1 , 2*index + 1);//左边
    //i- s为左子树的长度
    //cout<<"=================\n";
    solve(root - 1,i+1 , e , 2*index + 2);//右边

}
int main()
{
    memset(level,-1,sizeof(level));
    
    cin>>N;

    for(int i = 0;i < N;++i)
        cin>>postorder[i];
    
    for(int i = 0;i < N;++i)
        cin>>inorder[i];
    
   
    solve(N-1,0,N-1,0);
    int cnt = 1;
    for(int i = 0;i < 10005 && cnt <= N;++i)
    {
        if(level[i] != -1)
        {
            if(cnt != 1)
                cout<<" ";

            cout<<level[i];
            ++cnt;
        }
    }
    return 0;
}
```

### **1021** **Deepest Root** 

考点：连通分量，dfs，图的遍历

总结：如果图的连通分量不是1 ，则输出它的连通分量数；如果图的连通分量为1，则输出构成最深的树的高度时，树的根结点（遍历一个结点所得到的最深结点集合，从该集合中随机挑选任意一个结点再次进行遍历的得到另一个最深结点的集合，这两个集合求并集，即是构成最深的树的高度时，树的根结点集合）

```c++

#include<iostream>
#include<vector>
#include<algorithm>
#include<set>
using namespace std;
vector<vector<int> > G;
vector<bool> visited;
vector<int> temp;
set<int> st;
int max_deep = 0,N;
void dfs(int x,int deep)
{
    visited[x] = true;

    if(deep > max_deep)
    {
        max_deep = deep;
        temp.clear();
        temp.push_back(x);
    }
    else if(deep == max_deep)
    {
        temp.push_back(x);
    }

    for(auto &w : G[x])
    {
        if(!visited[w])
        {
            dfs(w,deep + 1);
        }
    }
}
int main()
{
    cin>>N;
    G.resize(N+1);
    visited.resize(N+1);

    for(int i = 1;i < N;++i)
    {
        int x,y;
        cin>>x>>y;
        G[x].push_back(y);
        G[y].push_back(x);
    }
    fill(visited.begin(),visited.end(),false);
    int ans = 0,s1;
    for(int i = 1;i <= N;++i)
    {
        if(!visited[i])
        {
            dfs(i,1);
            ++ans;
        }
        if(i == 1)
        {
            s1 = temp[0];
            for(int j = 0;j < temp.size();++j)
                st.insert(temp[j]);
        }
    }
    if(ans >= 2)
    {
        cout<<"Error: "<<ans<<" components\n";
    }
    else 
    {
        max_deep = 0;
        fill(visited.begin(),visited.end(),false);
        temp.clear();
        dfs(s1,1);

        for(int j = 0;j < temp.size();++j)
            st.insert(temp[j]);
        for(auto &c : st)
        {
            cout<<c<<endl;
        }
    }
    return 0;
}
```

### **1023** **Have Fun with Numbers** 

考点：大数运算

总结：本题是给定一个数，查看它的倍数doublenum,是否由其组成的数字排列而成。注意：其倍数最高位是否有进位。

```c++
#include<iostream>
#include<string>
using namespace std;
int book[10];
int main()
{
    string num;
    cin>>num;

    int digit = 0;

    int l = int(num.size());
    for(int i = l - 1;i >= 0;--i)
    {
        int temp = num[i] - '0';
        book[temp]++;

        temp = temp * 2 + digit;

        digit = temp/10;//进位
        temp = temp % 10;//当前位
        num[i] = (temp + '0');
        
        book[temp]--;
    }
    int flag = 0;
    for(int i = 0;i < 10;++i)
    {
        if(book[i] != 0)
            flag = 1;
    }
    cout<<((flag == 1 || digit == 1) ? "No\n" : "Yes\n");
    if(digit == 1)
        cout<<"1";
    cout<<num<<endl;
    return 0;
}
```

### **1024** **Palindromic Number** 

考点：回文数，大数运算

总结：注意处理大数运算过程中的进位问题

```c++
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
string additionLargeNum(string str1,string str2)
{
    int l = int(str1.size());
    int digit = 0;
    for(int i = l - 1;i >= 0;--i)
    {
        int temp = (str1[i] - '0')+ (str2[i] - '0') + digit;
        digit = temp/10;
        str1[i] = (temp%10) + '0';
    }

    if(digit)
        str1 = to_string(digit) + str1;
    return str1;
}
int main()
{
    string str;
    cin>>str;
    int k;
    cin>>k;
    
    int i = 1;
    for(;i <= k;++i)
    {
        string ctr = str;
        reverse(ctr.begin(),ctr.end());
        if(ctr == str)
            break;
        str = additionLargeNum(str,ctr);
    }
    cout<<str<<endl;
    cout<<i-1<<endl;
    return 0;
}
```

### **1025** **PAT Ranking**

考点：排序

总结：分集合排序，合并排序。注意在合并的过程中不要漏掉元素

```c++
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
using namespace std;
int N,K;
struct node
{
    string name;
    int final_rank;
    int location_number;
    int local_rank;
    int score;
};
bool cmp1(node &e1,node &e2)
{
    if(e1.score != e2.score)
         return e1.score > e2.score;
    else 
        return e1.name < e2.name;
}
vector<node> mergedRanklist;
int main()
{
    cin>>N;

    for(int i = 0;i < N;++i)
    {
        cin>>K;
        vector<node> t(K);
        for(int j = 0;j < K;++j)
        {
            string id;
            int sc;
            cin>>id>>sc;
            t[j].name = id;
            t[j].score = sc;
            t[j].location_number = i + 1;
       
        }

        sort(t.begin(),t.end(),cmp1);

        t[0].local_rank = 1;
        mergedRanklist.push_back(t[0]);
        for(int i = 1;i < t.size();++i)
        {
            t[i].local_rank = i + 1;
            if(t[i].score == t[i-1].score)
                t[i].local_rank = t[i-1].local_rank;
            
            mergedRanklist.push_back(t[i]);
        }
    }
    sort(mergedRanklist.begin(),mergedRanklist.end(),cmp1);
    mergedRanklist[0].final_rank = 1;
    for(int i = 1;i < mergedRanklist.size();++i)
    {
        mergedRanklist[i].final_rank = i + 1;
        if(mergedRanklist[i].score == mergedRanklist[i - 1].score)
            mergedRanklist[i].final_rank = mergedRanklist[i-1].final_rank;
    }
    cout<<mergedRanklist.size()<<endl;
    for(auto &e : mergedRanklist)
    {
        cout<<e.name<<" "<<e.final_rank<<" "<<e.location_number<<" "<<e.local_rank<<endl;
    }
    return 0;
}
```

### **1027** **Colors in Mars** 

考点：进制转换，字符处理

总结：题目大致意思是将给定的十进制转换为13进制的形式，并且13进制的宽度为2，也就是不足两位填0即可。特别注意的是10到12用大写字母表示，这里利用字符串进行存储，以对应下标的形式将其输出即可。

```c++
#include<iostream>
#include<vector>
using namespace std;
int getRadix(int x)
{
    return (x/13)*10 + (x%13);
}
char signTable[14] ="0123456789ABC";
int main()
{
    int a,b,c;
    cin>>a>>b>>c;


    printf("#");
    printf("%c%c%c%c%c%c",signTable[a/13],signTable[a%13],signTable[b/13],signTable[b%13],signTable[c/13],signTable[c%13]);
    return 0;
}
```

### **1031** **Hello World for U** 

考点：字符串处理，公式计算

总结：题意大致：将字符串平分三分，两边的高度相等尽可能大（也就是向下取整 ）。剩下的长度就是两边字符之间所夹着的字符的个数了（也是两边之间空格的个数）。

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str;
    getline(cin,str);

    int l = int(str.size());
    int n = (l + 2)/3;//n1和n2的长度

  //  cout<<"n--------"<<n<<endl;

    int bm = l - 2*n; //bm + 2就是 n3的长度
    int i;
   // cout<<"bm--------"<<bm<<endl;
    for(i = 0;i < n - 1;++i)
    {
        cout<<str[i];
        for(int j = 0;j < bm;++j)
            cout<<" ";
        cout<<str[l - i - 1]<<endl;
    }
    
    for(;i <= n + bm;++i)
        cout<<str[i];
    //cout<<"-------i"<<i<<endl;


    return 0;
}		
```

### **1035** **Password** 

考点：字符串的处理

总结：注意输出格式的要求，在所有密码都不需要修改的情况下，注意n的单复数形式在英文中的表达方式

```c++
cout<<"There "<<(n == 1 ? "is" : "are")<<" "<<n<<" account"<<(n == 1 ? "" : "s")<<" and no account is modified\n";
```

```c++
#include<iostream>
#include<string>
#include<vector>
using namespace std;
using pii = pair<string,string>;
vector<pii> re;
int ans;
char modified(char c)
{
    
    if(c == '0')
    {
        return '%';
    }
    else if(c == 'l')
    {
        return 'L';
    }else if(c == '1')
    {
        return '@';
    }else if(c == 'O')
    {
        return 'o';
    }
    else 
    {
        ++ans;
        return c;
    }

}
int main()
{
    int n;
    cin>>n;
    int cnt = 0;
    for(int i = 0;i < n;++i)
    {
        ans = 0;
        string str1,str2;
        cin>>str1>>str2;
        for(int j = 0;j < str2.size();++j)
        {
            str2[j] = modified(str2[j]);
        }
        if(ans != str2.size())
        {
            ++cnt;
            re.push_back({str1,str2});
        }
    }
    if(cnt == 0)
    {
        cout<<"There "<<(n == 1 ? "is" : "are")<<" "<<n<<" account"<<(n == 1 ? "" : "s")<<" and no account is modified\n";
    }
    else 
    {
        cout<<cnt<<endl;
        for(auto &w : re)
        {
            cout<<w.first<<" "<<w.second<<endl;
        }
    }
}
```

### **1041** **Be Unique**

考点：

总结：标记第一个出现的且在集合中不重复的数字

```c++
#include<iostream>
#include<vector>
using namespace std;
int flag[100005];
int main()
{
    int n;
    cin>>n;
    vector<int> st;
    for(int i = 0;i < n;++i)
    {
        int x;
        cin>>x;
        flag[x]++;
        st.push_back(x);
    }
    bool winer = false;
    for(auto &e : st)
    {
        if(flag[e] == 1)
        {
            winer = true;
            cout<<e<<endl;
            break;
        }
    }
    cout<<(!winer ? "None\n" : "");
    return 0;
}
```

### **1042** **Shuffling Machine** 

考点：数组

总结：题目给定循环的次数以及洗牌过程中每张牌所应放的位置

```c++
#include<iostream>
#include<string>
#include<algorithm>
#include<cstring>
#include<vector>
#include<cmath>
using namespace std;
vector<string> st(54);
int start[55],ed[55],scan[55];
int main()
{
    char M[5] = {'S','H','C','D','J'};
    for(int i = 0;i < 54;++i)
    {
        int index = (i % 13) + 1;
        int ic = (i / 13);
        char c = M[ic];
        st[i].push_back(c);

        st[i] = st[i] + to_string(index);
    }
   /* for(int i = 0;i < 54;++i)
        cout<<" "<<st[i];
    cout<<endl;*/
    int n;
    cin>>n;
    vector<int> order;
    for(int i = 0;i < 54;++i)
    {
        int x;
        cin>>x;
        //i移动到 x
        scan[i] = x-1;
        //结束的位置
        ed[i] = i;
    }
    for(int j = 0;j < n;++j)
    {
        for(int i = 0;i < 54;++i)
        {
            start[i] = ed[i];//开始的位置
        }
        for(int i = 0;i < 54;++i)
        {
           ed[scan[i]] = start[i];//结束的位置
        }
    }
    for(int i = 0;i < 54;++i)
    {
        cout<<(i != 0 ? " " : "")<<st[ed[i]];
    }
    cout<<endl;
    return 0;
}
//S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5
/*
1
36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47
*/
```

### **1046** **Shortest Distance** 

考点：数组

总结：循环路径，计算x,y两点的两个路径的最小值即可。（sum为圈的总长，dis[y-1] - dis[x-1]为两点之间的长度。剩下的是另一条路的长度。

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int dis[100005];
int main()
{
    int n;
    cin>>n;
    int sum = 0;
    for(int i = 1;i <= n;++i)
    {
       cin>>dis[i];
       sum += dis[i];
       dis[i] = sum;
    }
    int k;
    cin>>k;
    while(k--)
    {
        int x,y;
        cin>>x>>y;
        if(x > y)
            swap(x,y);
        int temp = dis[y - 1] - dis[x-1];
        cout<<min(temp,sum - temp)<<endl;
    }
    return 0;
}
```

###  **1050** **String Subtraction**

考点：字符串

总结： 用set容器判断是否第一个字符串中的字符是否在第二个字符串中出现过。

```c++
#include<iostream>
#include<string>
#include<vector>
#include<set>
#include<algorithm>
using namespace std;
int main()
{
    set<char> st;
    string str1,str2;
    getline(cin,str1);
    getline(cin,str2);
    for(auto &c : str2)
    {
        st.insert(c);
    }
    for(auto &w : str1)
    {
        if(!st.count(w))
            cout<<w;
    }

    return 0;
}
```

### **1054** **The Dominant Color**

考点：

总结：找到出现次数最多的元素

```c++
#include<iostream>
#include<map>
#include<string>
using namespace std;
string answer;
map<string,int> ms;
int M,N,max_cnt = 0;
int main()
{
    cin>>M>>N;
    for(int i = 0;i < M;++i)
    {
        for(int j = 0;j < N;++j)
        {
            string color;
            cin>>color;
            ms[color]++;
            if(max_cnt < ms[color])
            {
                max_cnt = ms[color];
                answer = color;
            }
        }
    }
    cout<<answer<<endl;
    return 0;;
}
```

### **1058** **A+B in Hogwarts**

考点：大数运算

总结：考虑进位的情况

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int a1,a2,a3,b1,b2,b3;
    scanf("%d.%d.%d %d.%d.%d",&a1,&a2,&a3,&b1,&b2,&b3);
    int digit;
    digit = (a3 + b3) / 29;
    a3 = (a3 + b3) % 29;
    int sum = a2 + b2 + digit;
    a2 = sum % 17;
    digit = sum / 17;
    a1 = (a1 + b1 + digit);

    printf("%d.%d.%d",a1,a2,a3);
    return 0;
}
```

### **1061** **Dating** 

考点：字符串处理

总结：注意相同字符的判断（两个字符串中第几个相同的字符），对相同的字符的形式区分（A-G, 0-9，A - N,大小写，)

```c++
#include<iostream>
#include<string>
#include<set>
using namespace std;
int main()
{
    string str1,str2;
    string day[7]  = {"MON","TUE","WED","THU","FRI","SAT","SUN"};
    getline(cin,str1);
    getline(cin,str2);
    char firstC,secondC;
    int j = 0;
    while(j < str1.size() && j < str2.size())
    {
        if(str1[j] == str2[j] && (str1[j] <= 'G' && str1[j] >= 'A'))
            break;

        ++j;
    }
    firstC = str1[j];
    ++j;
    while(j < str1.size() && j < str2.size())
    {
        if((str1[j] == str2[j] && ((str1[j] >= 'A' && str1[j] <= 'N') || isdigit(str1[j]))))
            break;
        ++j;
    }
    secondC = str1[j];
 //   cout<<"========="<<secondC<<endl;
    string dt = day[firstC - 'A'];
    int hh = (isdigit(secondC) ? (secondC - '0') : (secondC - 'A' + 1) + 9);
    getline(cin,str1);
    getline(cin,str2);
    int l1 = int(str1.size()), l2 = int(str2.size());
    int i = 0;
    while(i < l1 && i < l2)
    {
        if(str1[i] == str2[i] && isalpha(str1[i]))
            break;
        ++i;
    }
    int mm = i;
    cout<<dt<<" ";
    printf("%02d:%02d\n",hh,mm);
    return 0;
}
```

### **1101** **Quick Sort** 

考点：快速排序，主元的位置

总结：两个数组分别存放初始位置以及排序后的位置，初始位置对应排序后的位置一致就可能是pivot（此时再比较其左边最大元素是否超过其大小，如果左边元素的最大值没有超过该数值，即为枢轴）。

最后没有找到为什么输出格式要在最后换行。

```c++
#include<iostream>
#include<vector>
#include<set>
#include<algorithm>
using namespace std;
vector<int> a,b;
set<int> st;
int N;
int main()
{
    int max_left = 0;
    cin>>N;
    a.resize(N);
    b.resize(N);
    for(int i = 0;i < N;++i)
    {
        cin>>a[i];
        b[i] = a[i];
    }
    sort(a.begin(),a.end());
    for(int i = 0;i < N;++i)
    {
        if(a[i] == b[i] && max_left < b[i])
            st.insert(b[i]);
        max_left = max(max_left,b[i]);
    }
    int cnt = int(st.size());
    cout<<cnt<<endl;
    int i = 0;
    for(auto &w : st)
    {
        cout<<((i++)!= 0 ? " " : "")<<w;
    }
    cout<<endl;
    return 0;
}
```

### **1100** **Mars Numbers** 

考点：字符串，取余操作，进制数

总结：判断是火星文还是地球文。火星文：注意有几位数，找到对应数值的下标即可。地球文：判断高位如果有高位，注意是否有低位，有高位并且有低位才输出空格。低位输出分两种（非零值和零值）。0-168 （0 ~ 12,13 ~168）。还要特别注意输出格式。

0 和 130的特殊情况

```c++
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
string onedig[13] = {"tret","jan","feb","mar","apr","may","jun","jly","aug","sep","oct","nov","dec"};
string secdig[13] = {"###","tam","hel","maa","huh","tou","kes","hei","elo","syy","lok","mer","jou"};
int N;
//注意，还有个数字0没有考虑，因为数字0取余13等于0，但是要特别输出tret，所以在func1的最后一句判断中加一句t == 0，
//并将a[0]位赋值成tret即可解决0的问题～
void fun1(string str)
{
    int  num = stoi(str);

    int firstdigit = num % 13;
    int seconddigit = num / 13;
    if(seconddigit)
    {
        cout<<secdig[seconddigit];
    }
    if((seconddigit)&&(firstdigit))
        cout<<" ";
    if(firstdigit || num == 0)
          cout<<onedig[firstdigit];
}
void fun2(string str)
{
    int  t1 = 0, t2  = 0;
    string s1 = str.substr(0,3),s2;

    if(str.length() > 4)
        s2 = str.substr(4,3);

    for(int j = 1;j <= 12;++j)
    {
        if(s1 == onedig[j] || s2 == onedig[j]) 
            t2 = j;

        if(s1 == secdig[j])
            t1 = j;
    }
    cout<<t1 * 13 + t2;
}
int main()
{
   cin>>N;
   getchar();
   while(N--)
   {
       string str;
       getline(cin,str);
       string s1,s2;
       if(isdigit(str[0]))
       {
            fun1(str);
       }
       else 
       {
           fun2(str);
       }
       cout<<endl;
   }
    return 0;
}
```

### **1154** **Vertex Coloring** 

考点：图的存储，DFS,BFS,并查集

总结：有向图，无向图

```c++
//深度优先搜索
#include<iostream>
#include<vector>
#include<set>
#include<algorithm>
using namespace std;
int N,M,K;
vector<vector<int> > G;
vector<int> color;
vector<bool> visited;
bool flag;
void dfs(int x)
{
    if(!flag)
        return;
    visited[x] = true;
    for(auto &w :G[x])
    {
        if(color[x] == color[w])
            {flag = false;
            break;}

        if(!visited[w])
        {
           dfs(w);
        }
    }
}
bool judge()
{
    fill(visited.begin(),visited.end(),false);
    flag = true;
    for(int i = 0;i < N;++i)
    {
        if(!visited[i])
            dfs(i);
    }
    return flag;
}
int main()
{
    cin>>N>>M;
    G.resize(N);
    color.resize(N);
    visited.resize(N);
    for(int i = 0;i < M;++i)
    {
        int x,y;
        cin>>x>>y;
        G[x].push_back(y);
        
    }
    cin>>K;
    while(K--)
    {
        set<int> st;
        for(int i = 0;i < N;++i)
        {
            cin>>color[i];
            st.insert(color[i]);
        }
        int  num = st.size();
        if(judge())
        {
            cout<<num<<"-coloring\n";
        }
        else 
        {
            cout<<"No\n";
        }
    }
    return  0;
}
```

另一种dfs

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<set>
using namespace std;
vector<vector<int> > G;
vector<bool> visited;
vector<int> color;
set<int> st;
int N,M,k;
bool dfs(int x)
{
    visited[x] = true;
    for(auto &w : G[x])
    {
        if(color[w] == color[x])
            return false;
        if(!visited[w]&&!dfs(w))
            return false;
    }
    return true;
}
bool judge()
{
    fill(visited.begin(),visited.end(),false);
    for(int i = 0;i < N;++i)
    {
        if(!visited[i]&&!dfs(i))
            return false;
    }
    return true;
}
int main()
{
    cin>>N>>M;
    visited.resize(N);
    G.resize(N);
    color.resize(N);

    for(int i = 0;i < M;++i)
    {
        int x,y;
        cin>>x>>y;
        G[x].push_back(y);
    }
    cin>>k;
    while(k--)
    {
        set<int> colornum;
        for(int i = 0;i < N;++i)
        {
            cin>>color[i];
            colornum.insert(color[i]);
        }
        int num = colornum.size();

       if(judge())
        {
            cout<<num<<"-coloring\n";
        }
        else 
        {
            cout<<"No\n";
        }
    }
    return 0;
}	
```

方法三：

```c
#include<iostream>
#include<vector>
#include<set>
using namespace std;
using pii = pair<int,int>;
int connect[10005][10005];
vector<int> color;
vector<pii> edge;

int N,M,K;
bool judge()
{
    for(auto &e : edge)
    {
        int x = e.first, y = e.second;
        if(color[x] == color[y])
            return false;
    }
    return true;
}
int main()
{
    cin>>N>>M;
    color.resize(N);

    for(int i = 0;i < M;++i)
    {
        int x,y;
        cin>>x>>y;
        connect[x][y] = connect[y][x] = 1;
        edge.push_back({x,y});
    }
    cin>>K;
    while(K--)
    {
        set<int> colornum;
        for(int i = 0;i < N;++i)
        {
            cin>>color[i];
            colornum.insert(color[i]);
        }
        if(judge())
        {
            cout<<colornum.size()<<"-coloring\n";
        }
        else 
        {
            cout<<"No\n";
        }
    }
    return 0;
}
```

### **1098** **Insertion or Heap Sort** 

考点：插入排序，堆排序

总结：插入排序，题目中未排序序列位于排序序列的后侧；堆排序，未排序序列位于排序序列的前侧。要熟悉堆排序中，未排序序列的堆调整的过程；插入排序的排序过程。注意：本题中，堆排序中未排序序列的首部始终为最大值（满足堆的性质）

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int N;
vector<int> a,b;
void adjustHeap(int low,int high)
{
    //第一个元素为堆顶元素
    int i = low,j = 2*i;
    //大根堆做下沉操作
    while(j <= high)
    {
        //找到孩子节点最大的与其交换位置
        if(j + 1 <= high && b[j + 1] > b[j])
                ++j;
        if(b[j] > b[i])
        {
            swap(b[j],b[i]);
            i = j;
            j = 2*i;
        }
        else 
        {
            break;
        }
    }
}
int main()
{
    cin>>N;
    a.resize(N+1);
    b.resize(N+1);
    for(int i = 1;i <= N;++i)
        cin>>a[i];
    for(int i = 1;i <= N;++i)
        cin>>b[i];

    int  p = 2;
    //判断是否是插入排序，前面是否已经排好
    while(p <= N && b[p-1] <= b[p])
        ++p;
    int index = p;//插入排序过程中未排序序列中的第一个元素
    ///后面是否和初始相同
    while(p <= N && a[p] == b[p])
        ++p;
    if(p == N + 1)
    {

        cout<<"Insertion Sort\n";
        sort(b.begin() + 1,b.begin() + index + 1);
        for(int i = 1;i <= N;++i)
        {
            cout<<(i != 1 ? " " : "")<<b[i];
        }
        cout<<endl;
    }
    else 
    {
        cout<<"Heap Sort\n";
        p = N;
        //找到堆排序中未排序序列的最后元素的位置
        while(p >= 2 && b[p-1] <= b[p])
            --p;
            //此时p的位置为为排序序列的末尾
        //--p;
        swap(b[1],b[p]);//第一个元素为未排序序列中的最大值，将其插入到排序序列的首部
        //对未排序序列进行堆调整
        adjustHeap(1,p-1);
        for(int i = 1;i <= N;++i)
        {
            cout<<(i != 1 ? " " : "")<<b[i];
        }
        cout<<endl;
    }
    
    return 0;
}
```

### **1152** **Google Recruitment**

考点：字符串

总结：注意边界情况

```c++
 for(int i = 0;i < str.size() - K + 1;++i)//最后k个字符的开始下标为：str.size() - k (下标从0开始)
```



```c++
#include<iostream>
#include<cmath>
#include<algorithm>
#include<string>
using namespace std;
bool judge(int x)
{
    for(int i = 2;i <= sqrt(x);++i)
    {
        if(x % i == 0)
            return false;
    }
    return true;
}
int  N,K;
int main()
{
    cin>>N>>K;
    getchar();
    string str,answer = "";
    getline(cin,str);
    
    for(int i = 0;i < str.size() - K + 1;++i)
    {
        string testnum = str.substr(i,K);
        if(judge(stoi(testnum)))
        {
            answer = testnum;
            break;
        }
    }
    cout<<(answer != "" ? answer+"\n" : "404\n");

    return 0;
}
```

### **1148** **Werewolf - Simple Version**

考点：模拟题，枚举

总结：条件：有两个说谎的人，一个是狼人一个不是狼人。枚举两个狼人，根据player的说话信息（某人是不是狼人）判断其与枚举情况是否符合，将不符合（也就是说谎的人存入集合），当找到第一个符合条件的集合即为答案。

```c++
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;
int main()
{
    int N;
    cin>>N;
    vector<int> talk(N + 1,0);
    for(int i = 1;i <= N;++i)
        cin>>talk[i];
    for(int i = 1;i <= N;++i)
    {
        for(int j = i + 1;j <= N;++j)
        {
            //1不是两人，-1是两人
            vector<int> a(N+1,1);
            a[i] = a[j] = -1;
            vector<int> lying;
            for(int k = 1;k <= N;++k)
            {
                //判断说话的人是否说谎
                int id = abs(talk[k]);
                //如果说谎则异号
                if(a[id]*talk[k] < 0)
                    lying.push_back(k);
            }
            //有两个人说谎，并且一个是狼人，一个不是狼人
            if(lying.size() == 2 && a[lying[0]] + a[lying[1]] == 0)
            {
                cout<<i<<" "<<j<<endl;
                return 0;
            }
        }
    }
    cout<<"No Solution\n";
    return 0;
}
```

### **1144** **The Missing Number** 

考点：数组

总结：用数组下标记录对应正整数是否出现过，注意段错误（数组越界）这里我该用了map容器，不再list中的最小正整数的范围则为1~N+1。

```c++
#include<iostream>
#include<map>
#include<algorithm>
using namespace std;
int N;
int main()
{
    cin>>N;
    map<int,int> MarkArray;
    for(int i = 0;i < N;++i)
    {
        int num;
        cin>>num;
        MarkArray[num]++;
    }
    int i = 1;
    for(;i <= N;++i)
    {
        if(MarkArray[i] == 0)
            break;
    }
    cout<<i<<endl;
    return 0;
}
```

### **1140** **Look-and-say Sequence** 

考点：字符串

总结：原有表达式 A=A+B改为A+=B这样不仅减少了敲入代码的数量，而且由于变量A只出现一次，在运行时也提高了系统的性能。否则可能会出现，运行超时：您的程序未能在规定时间内运行结束

```c++
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
int main()
{
   string str;
   int N;
   int j;
   cin>>str>>N;
   for(int cnt = 1;cnt < N;++cnt)
   {
     //  int len = int(str.size());
       string t;
       for(int i = 0;i < str.size();i = j)
       {
           for(j = i;j < str.size() && str[j] == str[i];j++);
           /*
           例如原有表达式 A=A+B
改为A+=B
这样不仅减少了敲入代码的数量，而且由于变量A只出现一次，在运行时也提高了系统的性能。*/
           t += str[i] + to_string(j - i);//这里会超时 x+=y等价于x=x+y和类型强制转换两个操作。
       }
       str = t;
   }
   cout<<str<<endl;
   return 0;
}
```

### **1136** **A Delayed Palindrome**

考点：字符串，大数运算，回文数

总结：判断一个数是否文回文数，不是回文数进行给定条件的加法操作，最多判断10次。注意：先判断在进行加法操作。

```c++
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;
string getCount(string str)
{
    string sum = str;
    int len = int(str.size());
    int digit = 0;
    int j = len - 1,i = 0;
    for(;i < len && j >= 0;++i,--j)
    {
        int x = (sum[j] - '0') + (str[i] - '0') + digit;
        sum[j] = (x%10 + '0');
        digit = x/10;
    }
    if(digit)
        sum = to_string(digit) + sum;
    return sum;
}
bool Ispalindromic(string str)
{
    int len = int(str.size());
    for(int i = 0;i < len/2;++i)
    {
        if(str[i] != str[len - 1 - i])
            return false;
    }
    return true;
}
int main()
{
    string str;
    getline(cin,str);
    int i;
    for(i = 0;i < 10;++i)
    {
        string ctr = str;
        reverse(ctr.begin(),ctr.end());
        if(Ispalindromic(str))
        {
            cout<<str<<" is a palindromic number.\n";
            break;
        }
        string x = getCount(str);
        cout<<str<<" + "<<ctr<<" = "<<x<<endl;
        str = x;
    }
    if(i == 10)
        cout<<"Not found in 10 iterations.\n";
    return 0;
}
```

### **1132** **Cut Integer**

考点：除法操作，浮点错误

总结：出现浮点错误，一般是指您的程序运行时发生浮点错误，比如遇到了除以 0 的情况

```c++
#include<iostream>
#include<string>
using namespace std;
int N;
string str;
int main()
{
    cin>>N;
    for(int i = 0;i < N;++i)
    {
        int c;
        cin>>c;
        string str = to_string(c);
        int  k = str.size() / 2;
        int a = stoi(str.substr(0,k));
        int b = stoi(str.substr(k));
        if(a*b == 0)
        {
            cout<<"No\n";
        }
        else 
        {
            cout<<(c % (a*b) == 0 ? "Yes\n" : "No\n");
        }    
    }
    return 0;
}
```

### **1128** **N Queens Puzzle**

考点：N皇后问题，数组

总结：是否在同一行或者斜着的方向

```c++
#include<iostream>
#include<cmath>
using namespace std;
int  k,n;
int row[1005];
int main()
{
    cin>>k;
    for(int i = 0;i < k;++i)
    {
        cin>>n;
        bool result  = true;
        for(int j = 0;j < n;++j)
        {
            cin>>row[j];
            for(int t = 0;t < j;++t)
            {
                if(row[t] == row[j] || abs(row[t] - row[j]) == (j - t))
                {
                    result = false;
                    break;
                }
            }
        }
        cout<<(result ? "YES\n" : "NO\n");
    }
    return 0;
}
```

### **1124** **Raffle for Weibo Followers**

考点：模拟题

总结：利用continue忽略获奖者。注意处理第一个获奖者。理解 the skip number of winners（获奖者步数）

```c++
#include<iostream>
#include<string>
#include<algorithm>
#include<set>
using namespace std;
set<string> pro;
int main()
{
    int M,N,S;
    cin>>M>>N>>S;
    int ans = 1,cnt = 0;
    for(int i = 0;i < M;++i)
    {
        string name;
        cin>>name;
        if(pro.count(name))
            continue;
        if((ans == S && cnt == 0)||(ans == N && cnt != 0))
        {
            cout<<name<<endl;
            pro.insert(name);
            ans = 0;
            ++cnt;
        }
        ++ans;
    }
    if(cnt == 0)
        cout<<"Keep going...\n";
    return 0;
}
```

### **1120** **Friend Numbers**

考点：字符串，数字

总结：

```c++
#include<iostream>
#include<set>
#include<string>
using namespace std;
int N,cnt;
set<int> st;
int getFriedId(string str)
{
    int sum = 0;
    for(auto &c : str)
    {
        sum += (c - '0');
    }
    return sum;
}
int main()
{
    cin>>N;
    for(int i = 0;i < N;++i)
    {
        string str;
        cin>>str;
        st.insert(getFriedId(str));
    }
    cnt = st.size();
    cout<<cnt<<endl;
    cnt = 0;
    for(auto &i : st)
    {
        cout<<(cnt++ != 0 ? " " : "")<<i;
    }
    return 0;
}
```

### **1116** **Come on! Let's C** 

考点：素数，数组，字符串，键值

总结：

```c++
#include<iostream>
#include<string>
#include<set>
#include<map>
#include<cmath>
using namespace std;
int N,K;
map<string,string> awardlist;
set<string> list;
bool isPrime(int x)
{
    for(int i = 2;i <= sqrt(x);++i)
    {
        if(x % i == 0)
            return false;
    }
    return true;
}
int main()
{
    cin>>N;
    for(int i = 1;i <= N;++i)
    {
        string name;
        cin>>name;
        list.insert(name);
        awardlist[name] = "Chocolate";
        if(isPrime(i))
            awardlist[name] = "Minion";
        if(i == 1)
            awardlist[name] = "Mystery Award";
    }
    cin>>K;
    for(int i = 0;i < K;++i)
    {
        string id;
        cin>>id;
        if(!list.count(id))
        {
            cout<<id<<": "<<"Are you kidding?\n";
        }
        else 
        {
            cout<<id<<": "<<awardlist[id]<<endl;
            awardlist[id] = "Checked";
        }
    }
    return 0;
}
```

### **1112** **Stucked Keyboard** 

考点：字符串，重复字符

总结：对坏掉的键输入进行处理，坏键会将单个字符重复输出固定的数目，而对于好键对应的字符连续时数目不固定。再处理给定字符串的过程中，可以在边界添加多余字符来处理特殊情况。

```c++
#include<iostream>
#include<string>
#include<set>
#include<map>
using namespace std;
map<char,bool> m;
set<char> st;
map<char,bool> iskey;
int main()
{
    int k;
    cin>>k;
    string str;
    cin>>str;
    char c = '#';
    str += c;
    int cnt = 1;
    for(int i = 0;i < str.size();++i)
    {
        if(c == str[i])
        {
            ++cnt;
        }
        else 
        {
            if(cnt % k != 0)
                iskey[c] = true;//一定是好键盘(不是对应的固定值)
            cnt = 1;
        }
        //难点
        if(i != str.size() - 1)  
            m[str[i]]  = (cnt % k == 0);//可能坏（还要判断重复时长度是否不等于k的倍数）
        c = str[i];
    }
    for(int i = 0;i < str.size() - 1;++i)
    {
        if(iskey[str[i]] == true)//确定坏键盘
        {
            m[str[i]] = false;//之前好的一定不坏
        }
    }
    for(int i = 0;i < str.size() - 1;++i)
    {
        if(m[str[i]]&&!st.count(str[i]))
        {
            cout<<str[i];
            st.insert(str[i]);
        }
    }
    cout<<endl;
    for(int i = 0;i < str.size() - 1;++i)
    {
        cout<<str[i];
        if(m[str[i]])
            i += k - 1;
    }
    return 0;
}
```

### **1108** **Finding Average**

考点：字符串

总结：

**sscanf() – 从一个字符串中读进与指定格式相符的数据**

**sprintf() – 字符串格式化命令，主要功能是把格式化的数据写入某个字符串中**

输出格式问题：注意英文中的单复数形式

```c++
#include<iostream>
#include<string>
#include<cmath>
#include<cstring>
using namespace std;
int main()
{
    string a;
    char b[50];
    int N,ans = 0;
    cin>>N;
    double temp = 0,sum = 0;
    for(int i = 0;i < N;++i)
    {
        cin>>a;
        sscanf(a.c_str(),"%lf",&temp);//以%lf的形式存入temp
        sprintf(b,"%.2f",temp);//以%.2f输出到b
        int flag = 0;
        for(int j = 0;j < a.size();++j)
        {
            if(a[j] != b[j])
            {
                flag = 1;
                break;
            }
        }
        if(flag || temp < -1000 || temp > 1000)
        {
            cout<<"ERROR: "<<a<<" is not a legal number\n";
        }
        else 
        {
            sum += temp;
            ++ans;
        }
    }
    if(ans == 0)
    {
        cout<<"The average of "<<ans<<" numbers is Undefined\n";
    }
    else 
    {
        double ave = sum/ans;
        cout<<"The average of "<<ans<<" number"<<(ans == 1 ? "" : "s")<<" is ";
        printf("%.2f\n",ave);
    }
    return 0;
}
```



考点：

总结：**将数列中的每个数字读取到temp中，假设我们选取的片段中包括temp，且这个片段的首尾指针分别为p和q，那么对于p，有i种选择，即12…i，对于q，有n-i+1种选择，即i, i+1, … n，所以p和q组合形成的首尾片段有i \* (n-i+1)种，因为每个里面都会出现temp，所以temp引起的总和为temp \* i \* (n – i + 1)；遍历完所有数字，将每个temp引起的总和都累加到sum中，最后输出sum的值～**

```c++
#include<iostream>
using namespace std;
int main()
{
    int n;
    cin>>n;
    long long sum = 0;
    for(int i = 0;i < n;++i)
    {
        double  x;
        cin>>x;
        sum += (long long)(x * 1000) * (i + 1) * (n - i);//防止精确度丢失
    }
    printf("%.2f\n",sum/1000.0);
    return 0;
}
```

### **1001** **A+B Format**

考点：字符串，取余

总结：输出数字的时候要判断该数字位数是否为3的倍数，是3的倍数需要在其前面加一个分隔符（确保不是最高位)

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int a,b;
    string sum;
    cin>>a>>b;
    a += b;
    if(a < 0)
    {
        cout<<"-";
        a = 0 - a;
    }
    sum = to_string(a);
    int len = int(sum.size());
    cout<<sum[0];
    for(int i = 1;i < len;++i)
    {
        if((len - i)% 3 ==0)
            cout<<",";
        cout<<sum[i];
    }
    cout<<"\n";
    return 0;
}
```

### **1005** **Spell It Right**

考点：字符串

总结：

```c++
#include<iostream>
#include<string>
#include<vector>
using namespace std;
vector<string> a = {"zero","one","two","three","four","five","six","seven","eight","nine"};
int main()
{
    string str;
    cin>>str;
    int sum = 0;
    for(auto &c : str)
    {
        sum += (c - '0');
    }
    string test = to_string(sum);
    cout<<a[(test[0] - '0')];
    for(int i = 1;i < test.size();++i)
    {
        cout<<" "<<a[(test[i] - '0')];
    }
    cout<<endl;
    return 0;
}
```

### **1002** **A+B for Polynomials** 

考点：运算，数组

总结：

总结：

```ruby
#include<iostream>
#include<math.h>
using namespace std;
double c1[1005],c2[1005];
int t1  = -1,t2 = -1;
int main()
{
    int n;
    cin>>n;
    for(int i = 0;i < n;++i)
    {
        int e;
        double co;
        cin>>e>>co;
        if(t1 == -1)
            t1 = e;
        c1[e] = co;
    }
    cin>>n;

    for(int i = 0;i < n;++i)
    {
        int e;
        double co;
        cin>>e>>co;
        if(t2 == -1)
        {
            t2 = e;
        }
        c2[e] = co;
    }
    int max_e = max(t1,t2);
    for(int i = 0;i <= max_e;++i)
    {
        c1[i] += c2[i];
    }
    int cnt = 0;
    for(int i = max_e ; i >= 0;--i)
    {
        if(abs(c1[i]) + 0.05 >= 0.1)
            ++cnt;
    }
    cout<<cnt;
    for(int i = max_e; i >= 0;--i)
    {
        if(abs(c1[i]) + 0.05 >= 0.1)
        {

            printf(" %d %.1f",i,c1[i]);
            cnt--;
            if(cnt == 0)
                break;
        }
    }
    return 0;
}
//C:\\mingw64\\bin\\g++.exe
```

### **1003** **Emergency** 

> 考点：迪杰斯特拉算法
>
> 总结：最短路径有几条，召集最多的救援队

```ruby
#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;
using pii = pair<int,int>;
struct edge
{
    int to,cost;
};
vector<int> dis,Rc,pre;
vector<vector<edge> > G;
vector<int> totalRescue,Rescue;
int N,M,c1,c2;
void Dijkstra()
{
    dis = vector<int>(N,0x3f3f3f3f);
    priority_queue<pii,vector<pii>,greater<pii> > pq;
    Rc[c1] = 1;
    dis[c1] = 0;
    totalRescue[c1] = Rescue[c1];
    pq.push({dis[c1],c1});

    while(!pq.empty())
    {
        auto v = pq.top();
        pq.pop();

        int x = v.second;
        if(dis[x] < v.first)
            continue;
        
        for(auto &e : G[x])
        {
            if(dis[e.to] > dis[x] + e.cost)
            {
                Rc[e.to] = Rc[x];
                totalRescue[e.to] = totalRescue[x] + Rescue[e.to];
                dis[e.to] = dis[x] + e.cost;
                pre[e.to] = x;

                pq.push({dis[e.to],e.to});
            }
            else if(dis[e.to] == dis[x] + e.cost)
            {
                Rc[e.to] += Rc[x];
                if(totalRescue[e.to] < totalRescue[x] + Rescue[e.to])
                {
                    pre[e.to] = x;
                    totalRescue[e.to] = totalRescue[x] + Rescue[e.to];
                }
            }
        }
    }
}
int main()
{
    cin>>N>>M>>c1>>c2;
    G.resize(N);
    pre.resize(N);
    totalRescue.resize(N);
    Rescue.resize(N);
    Rc.resize(N);
    for(int i = 0;i < N;++i)
    {
        cin>>Rescue[i];
    }
    for(int i = 0;i < M;++i)
    {
        int x,y,z;
        cin>>x>>y>>z;
        G[x].push_back({y,z});
        G[y].push_back({x,z});
    }
    Dijkstra();
    cout<<Rc[c2]<<" "<<totalRescue[c2]<<endl;
    return 0;
}
```

### **1006** **Sign In and Sign Out** 

> 考点：排序
>
> 总结：

```ruby
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
using namespace std;
using pii = pair<string,int>;
vector<pii> inl,outl;
bool cmp(pii &e1,pii &e2)
{
    return e1.second < e2.second;
}
int n;
int main()
{
    cin>>n;
    for(int i = 0;i < n;++i)
    {
        string str;
        cin>>str;
        int a1,a2,a3,b1,b2,b3;
        scanf("%d:%d:%d",&a1,&a2,&a3);
        scanf("%d:%d:%d",&b1,&b2,&b3);
        a1 = a1 * 60 * 60 + a2 * 60 + a3;
        b1 = b1 * 60 * 60 + b2 * 60 + b3;
        inl.push_back({str,a1});
        outl.push_back({str,b1});
    }
    sort(inl.begin(),inl.end(),cmp);
    sort(outl.begin(),outl.end(),cmp);
    cout<<inl[0].first<<" "<<outl.back().first<<endl;

    return 0;
}
```

###**1018** **Public Bike Management** 

考点：Dijkstra算法，dfs算法

总结：读懂题目意思，最短路，并且携带的自行车最少

```ruby
#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;
using pii = pair<int,int>;
struct edge
{
    int to,cost;
};
vector<vector<int> > pre;
vector<int> path,tempPath;
vector<int> weight,dis;
vector<vector<edge> > G;
int Cmax,N,Sp,M,result_need = 1<<30,result_back = 1<<30;
void dfs(int x)
{   
    tempPath.push_back(x);
    if(x == 0)
    {
        int need = 0,back = 0;
        int l = int(tempPath.size());
        for(int i = l - 1;i >= 0; --i)
        {
            int id = tempPath[i];
            if(weight[id] > 0)
            {
                back += weight[id];
            }
            else 
            {
                if(back > (0 - weight[id]))
                {
                    back += weight[id];
                }
                else 
                {
                    need += ((0 - weight[id]) - back);
                    back = 0;
                }
            }
        }

        if(need < result_need)
        {
            result_need = need;
            result_back = back;

            path = tempPath;
        }
        else if(need == result_need && back < result_back)
        {
            result_back = back;
            path = tempPath;
        }
        tempPath.pop_back();
        return ;
    }

    for(auto &e : pre[x])
    {
        dfs(e);
    }


    tempPath.pop_back();
}
void Dijkstra()
{
    dis = vector<int>(N+1,0x3f3f3f3f);
    dis[0] = 0;
    priority_queue<pii,vector<pii>,greater<pii> > pq;
    pq.push({dis[0],0});

    while(!pq.empty())
    {
        auto v = pq.top();
        pq.pop();

        int x = v.second;
        if(dis[x] < v.first)
            continue;
        
        for(auto &e : G[x])
        {
            if(dis[e.to] > dis[x] + e.cost)
            {
                dis[e.to] = dis[x] + e.cost;

                pre[e.to].clear();
                pre[e.to].push_back(x);

                pq.push({dis[e.to],e.to});
            }
            else if(dis[e.to] == dis[x] + e.cost)
            {
                pre[e.to].push_back(x);
            }
        }
    }
}
int main()
{   
    cin>>Cmax>>N>>Sp>>M;
    pre.resize(N+1);
    weight.resize(N+1);
    G.resize(N+1);

    for(int i = 1;i <= N;++i)
    {
        int num;
        cin>>num;
        weight[i] = num - Cmax/2;
    }

    for(int i = 0;i < M;++i)
    {
        int f,t,c;
        cin>>f>>t>>c;
        G[f].push_back({t,c});
        G[t].push_back({f,c});
    }
    Dijkstra();
    
    dfs(Sp);
    cout<<result_need;
    cout<<" 0";
    for(int i = path.size() - 2;i >= 0;--i)
    {
        cout<<"->"<<path[i];
    }
    cout<<" "<<result_back<<endl;
    return 0;
}
```

###**1022** **Digital Library**

考点：Hash函数

总结：给定键值查找id，利用set集合按序输出

```ruby
#include<iostream>
#include<string>
#include<set>
#include<map>
using namespace std;
int N,M;
map<string,set<string> > sm;
map<string,set<string> > keys;
int main()
{
    cin>>N;
    getchar();
    for(int i = 0;i < N;++i)
    {
        string id;
        getline(cin,id);
        sm[id].insert(id);
        for(int j = 0;j < 5;++j)
        {

            string ct;
            getline(cin,ct);

            sm[ct].insert(id);

            if(j == 2)
            {
                int sp = 0;
                ct.push_back(' ');
                for(int d = 0;d < ct.size();++d)
                {
                    if(ct[d] == ' ')
                    {
                        string kid = ct.substr(sp,d - sp);
                        keys[kid].insert(id);
                        sp = d + 1;
                    }
                }
            }
        }
    }
    cin>>M;
    getchar();
    for(int i = 0;i < M;++i)
    {
        string testStr;
        getline(cin,testStr);
        cout<<testStr<<endl;
        testStr = testStr.substr(3);
        if(!sm.count(testStr))
        {
            if(!keys.count(testStr))
            {
                cout<<"Not Found\n";
            }
            else 
            {
                for(auto &id : keys[testStr])
                {
                    cout<<id<<endl;
                }
            }
        }
        else 
        {
            
                for(auto &id : sm[testStr])
                {
                       cout<<id<<endl;
                }
            
        }
    }
    return 0;
}
```

### **1026** **Table Tennis** 

> 考点：排队
>
> 总结：送客，入队，迎客（优先考虑会员）

```ruby
#include<iostream>
#include<queue>
#include<algorithm>
using namespace std;
struct player
{
    int come_time,play_time,serve_time = 0,leave_time;
    int isvip = 0;
};
struct table
{
    int count = 0,serve = -1;//-1表示闲置
    int isvip = 0;
};
player p[10000];
table t[101];
vector<int> v;
bool comp(player x,player y)
{
    return x.come_time < y.come_time;
}
void printtime(int Time)
{
    printf("%02d:%02d:%02d ",Time/3600,Time%3600/60,Time%60);
}
int main()
{
    int N,K,M,i,j;//N个人，K个桌子，M会员桌子
    cin>>N;
    for(i = 0;i < N;++i)
    {
        int hh,mm,ss;
        char c;
        cin>>hh>>c>>mm>>c>>ss>>p[i].play_time>>p[i].isvip;
        p[i].come_time = hh * 3600 + mm * 60 + ss;
        p[i].play_time *= 60;
        if(p[i].play_time  > 7200)
            p[i].play_time = 7200;   
    }
    cin>>K>>M;
    while(M--)
    {
        cin>>i;
        t[i].isvip = 1;
    }
    sort(p,p + N,comp);
    queue<int> q1,q2;//1 普通队列 ， 2 会员队列
    int cursor = 0;
    for(int Time = 28800; Time < 75600;Time++)
    {
        for(i = 1;i <= K;++i)
        {
            if(t[i].serve >= 0)
            {
                j = t[i].serve;

                if(p[j].leave_time == Time)//可以走了
                {
                    t[i].serve = -1;
                }
            }
        }
        //送客
        while(cursor < N && p[cursor].come_time == Time)
        {
            q1.push(cursor);
            if(p[cursor].isvip)
            {
                q2.push(cursor);
            }
            cursor++;
        }
        //入队
        while(q2.size()&&p[q2.front()].serve_time != 0)//过滤有桌子的
        {
            q2.pop();
        }
        for(i = 1;i <= K;++i)
        {
            if(!t[i].isvip)//留下会员的桌子
            {
                continue;
            }
            if(t[i].serve < 0)//
            {
                if(q2.size())
                {
                    j = q2.front();
                    v.push_back(j);
                    t[i].serve = j;
                    t[i].count++;
                    p[j].serve_time = Time;
                    p[j].leave_time = Time + p[j].play_time;
                    while(q2.size()&& p[q2.front()].serve_time != 0)
                    {
                        q2.pop();
                    }
                }
            }
        }   
        while(q1.size()&&p[q1.front()].serve_time != 0)
        {
            q1.pop();
        }
        for(i = 1;i <= K;i++)
        {
            if(t[i].serve < 0)
            {
                if(q1.size())
                {
                    j = q1.front();
                    v.push_back(j);
                    t[i].serve = j;
                    t[i].count++;
                    p[j].serve_time = Time;
                    p[j].leave_time = Time + p[j].play_time;
                    while(q1.size()&&p[q1.front()].serve_time != 0)
                    {
                        q1.pop();
                    }
                }
            }
        }
        //迎客
    }
    for(auto &e : v)
    {
        printtime(p[e].come_time);
        printtime(p[e].serve_time);
        cout<<(p[e].serve_time - p[e].come_time + 30)/60<<endl;
    }
    for(int i = 1;i <= K;++i)
    {
        cout<<t[i].count<<(i != K ? " " : "\n");
    } 
    return 0;
}
```

### **1028** **List Sorting**

> 考点：排序
>
> 总结：根据数组中对应的内容排序

```ruby
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
using namespace std;
int N,C;
struct node
{
    string mes[3];
    bool operator<(const node &e)const
    {
        if(mes[C] != e.mes[C])
        {
            return mes[C] < e.mes[C];
        }
        else 
        {
            return mes[0] < e.mes[0];
        }

    }
};
vector<node> peo;
int main()
{
    cin>>N>>C;
    C--;
    for(int i = 0;i < N;++i)
    {
        string id,name,grade;
        cin>>id>>name>>grade;
        peo.push_back({id,name,grade});
    }
    sort(peo.begin(),peo.end());
    for(auto &e : peo)
    {
        cout<<e.mes[0]<<" "<<e.mes[1]<<" "<<e.mes[2]<<endl;
    }
    return 0;
}
```

###**1029** **Median**

> 考点：排序
>
> 总结：也可以用二分查找

```ruby
#include<iostream>
#include<vector>
#include<cmath>
#include<limits.h>
#include<algorithm>
using namespace std;
vector<int> v1,v2;
int main()
{
    int n,m;
    cin>>n;
    for(int i = 0;i < n;++i)
    {
       int x;
        cin>>x;
        v1.push_back(x);
    }
    cin>>m;
    for(int i = 0;i < m;++i)
    {
        int x;
        cin>>x;
        v2.push_back(x);
    }
    int target = ( n + m + 1)/2;
    int i = 0,j = 0,cnt = 0,ans = 0;
    while(i < n && j < m)
    {
        ans = (v1[i] <= v2[j] ? v1[i++] : v2[j++]);
        if(++cnt == target)
            break;
    }
    while(i < n && cnt < target)
    {
        ans = v1[i++];
        ++cnt;
    }
    while(j < m && cnt < target)
    {
        ans = v2[j++];
        ++cnt;
    }
    cout<<ans<<endl;
    return 0;
}
```

###**1030** **Travel Plan**

> 考点：Dijkstra算法
>
> 总结：

```ruby
#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;
using pii = pair<int,int>;
struct edge
{
    int to,l,c;
};
vector<int> totalC;
vector<int> pre;
vector<int> dis;
vector<vector<edge> > G;
int N,M,S,D;
void Dijkstra()
{
    dis = vector<int>(N,0x3f3f3f3f);
    dis[S] = 0;
    priority_queue<pii,vector<pii>,greater<pii> > pq;
    pq.push({dis[S],S});
    pre[S] = -1;
    totalC[S] = 0;
    while(!pq.empty())
    {
        auto v = pq.top();
        pq.pop();
        int x = v.second;
        if(dis[x] < v.first)
            continue;
        for(auto &e : G[x])
        {
            if(dis[e.to] > dis[x] + e.l)
            {
                dis[e.to] = dis[x] + e.l;
                pre[e.to] = x;
                totalC[e.to] = totalC[x] + e.c;
                pq.push({dis[e.to],e.to});
            }
            else if(dis[e.to] == dis[x] + e.l)
            {
                if(totalC[e.to]  > totalC[x] + e.c)
                {
                    pre[e.to] = x;
                    totalC[e.to] = totalC[x] + e.c;
                }
            }
        }
    }
}
void printPath(int x)
{
    if(pre[x] == -1)
    {
        cout<<x;
        return;
    }
    printPath(pre[x]);
    cout<<" "<<x;
}
int main()
{
    cin>>N>>M>>S>>D;
    G.resize(N);
    pre.resize(N);
    totalC.resize(N);
    for(int i = 0;i < M;++i)
    {
        int x,y,l,c;
        cin>>x>>y>>l>>c;
        G[x].push_back({y,l,c});
        G[y].push_back({x,l,c});
    }
    Dijkstra();
    printPath(D);
    cout<<" "<<dis[D]<<" "<<totalC[D]<<endl;
    return 0;
}
```

### **1032** **Sharing** 

***

> 总结：链表遍历
>
> 考点：链表

```ruby
#include<iostream>
using namespace std;
const  int max_n = 1000005;
struct node
{
    int key;
    int next;
    bool flag = false;
};
node na[max_n];
int N,firstH,secondH;
int main()
{
    cin>>firstH>>secondH>>N;
    for(int i = 0;i < N;++i)
    {
        int address,nextaddress;
        char c;
        cin>>address>>c>>nextaddress;
        na[address].key = c;
        na[address].next = nextaddress;
    }
    for(;firstH != -1;firstH = na[firstH].next)
    {
        na[firstH].flag = true;
    }
    for(;secondH != -1;secondH = na[secondH].next)
    {
        if(na[secondH].flag == true)
        {
            printf("%05d",secondH);
            return 0;
        }
    }
    cout<<"-1\n";
    return 0;
}
```

### **1033** **To Fill or Not to Fill** 

> 考点：贪心
>
> 总结：注意油量是否加满（加满或者加到刚刚到达某站）

```ruby
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
struct station{
    double price;
    double distance;
};
double CMAX,D,Davg;
int N;
bool cmp(station &n1,station &n2)
{
    return n1.distance < n2.distance;
}
int main()
{
    cin>>CMAX>>D>>Davg>>N;
    vector<station> st(N+1);
    st[0] = {0.0,D};//目的地

    for(int i = 1;i <= N;++i)
    {
        cin>>st[i].price>>st[i].distance;
    }
    sort(st.begin(),st.end(),cmp);
    if(st[0].distance != 0)
    {
        cout<<"The maximum travel distance = 0.0";
        return 0;
    }
    double nowprice = st[0].price,nowdis = 0,maxdis = 0,leftdis = 0,totalPrice = 0;
    while(nowdis < D)
    {
        maxdis = nowdis + CMAX * Davg;
        double minPrice = 0x3f3f3f3f,minDis = 0;//找到前方汽油站的价格最小的 和 位置
        bool flag = false;

        for(int  i = 1;i <= N && st[i].distance  <= maxdis;++i)
        {
            if(st[i].distance <= nowdis)
                continue;

            if(st[i].price < nowprice)//把汽油加到刚刚到达那里
            {
                //汽油加到刚刚到达那里， （减去此时的距离和剩余汽油所能走的距离）
                totalPrice += ((st[i].distance - nowdis - leftdis)/Davg)*nowprice;
                leftdis = 0;
                nowdis = st[i].distance;
                nowprice = st[i].price;
                flag = true;
                break;
            }

            //找最小的价格
            if(minPrice > st[i].price)
            {
                minDis = st[i].distance;
                minPrice = st[i].price;
            }
        }
        ///找到最小的价格 但是 比当前的要大 则加满之后再去那里
        //找不到比当前价格小的；1 找最小的 如果找不到最小的即到不了第一个站
        if(flag == false && minPrice != 0x3f3f3f3f)
        {
            //加了多少汽油（此时应当把汽油加满）：最大容量 减去 剩余油量
            totalPrice += (CMAX - leftdis/Davg)*nowprice;
            //到到这里的时候 剩余多少汽油
            leftdis = (CMAX*Davg - (minDis - nowdis));

            nowdis = minDis;
            nowprice = minPrice;
        }
        //到不了下一个加油站
        if(flag == false && minPrice == 0x3f3f3f3f)
        {//说明到达下一站的汽油不够了
            double sum = Davg * CMAX + nowdis;
            printf("The maximum travel distance = %.2f",sum);
            return 0;
        }

    }
    printf("%.2f",totalPrice);
    return 0;
}
```

> 方法二

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
typedef struct gas
{
    double pric,dis;//汽油站的结构体：距离和价格
}Gas;
bool cmp(Gas a,Gas b) //按照距离顺序排序
{
    return a.dis < b.dis;
}
int main()
{
    double c,ds,dv;
    int n;
    cin>>c>>ds>>dv>>n;
    vector<Gas> v(n+1);
    for(int i = 0;i < n;++i)
    {
        cin>>v[i].pric>>v[i].dis;
    }
    v[n].pric = 0;//将目的地作为一个价格为0的加油站
    v[n].dis = ds;
    sort(v.begin(),v.end(),cmp);
    if(v[0].dis != 0)
    {
        printf("The maximum travel distance = 0.00");
        return 0;
    }
    double tank = 0,maxd = c * dv, sum = 0;//tank表示当前邮箱存储量，maxd表示满邮箱的最远距离
    int now = 0;//now表示现在的站点
    while(1)
    {
        int next = -1;//next表示下一站
        double min = 0x3f3f3f3f; //记录下一站的最低价格
        for(int i = now + 1;i <= n && v[now].dis + maxd >= v[i].dis;i++)//在满邮箱能到达的范围内寻找价格
        {
            if(v[i].pric < min)
            {
                min = v[i].pric;
                next = i;
                if(min < v[now].pric)//如果最低价格低于当前价格，则直接去这个
                {
                    break;
                }
            }
        }
        if(next == -1)//如果下一站不可到达，终止并输出
        {
            printf("The maximum travel distance = %.2f",v[now].dis + maxd);
            break;
        }
        double need = (v[next].dis - v[now].dis)/dv; //need表示当前站到下一站的距离所需要的油
        if(min < v[now].pric)//如果下一站的价格低于当前，则只要能到下一站
        {
            if(tank < need)
            {
                sum += (need - tank)*v[now].pric;
                tank = 0;//更新到下一站时候的剩余量
            }
            else 
            {
                tank -= need;//如果不需要加油，直接去
            }
        }
        else
        {
            sum += (c - tank)*v[now].pric;//如果下一站比较贵，在这一站直接加满
            tank = c - need;
        }
        
        now = next;//更新当前站
        if(next == n)//如果下一站是终点，则输出结果，停止循环
        {
            printf("%.2f",sum);
            break;
        }
    }
    return 0;
}
```

### **1036** **Boys vs Girls**

> 考点：排序
>
> 总结：找最高分的女生和最低分的男生

```ruby
#include<iostream>
#include<vector>
#include<cmath>
#include<algorithm>
using namespace std;
int main()
{
    string fmale,male;
    int n;
    int minM = 101,maxF = -1;
    cin>>n;
    for(int i = 0;i < n;++i)
    {
        string name,gender,id,grade;
        cin>>name>>gender>>id>>grade;
        if(gender == "F")
        {
            if(stoi(grade) > maxF)
            {
                maxF = stoi(grade);
                fmale = name + " " + id + "\n";
            }
        }
        else 
        {
            if(stoi(grade) < minM)
            {
                minM = stoi(grade);
                male = name + " " + id + "\n";
            }
        }
    }

    if(maxF != -1)
    {
        cout<<fmale;
    }
    else 
    {
        cout<<"Absent\n";
    }

    if(minM != 101)
    {
        cout<<male;
    }
    else 
    {
        cout<<"Absent\n";
    }
    if(minM != 101 && maxF != -1)
    {
        cout<<abs(minM - maxF);
    }
    else 
    {
        cout<<"NA";
    }
    return 0;
}
```

### **1153** **Decode Registration Card of PAT**

> 考点：排序，超时问题
>
> 总结：使用scanf ，printf 要比cin ，cout 速度快，在输入样例的过程中尽量减少定义变量的次数（也就是把输入要用到的变量一次声明完成）。string可以利用 `c_str`转换成字符数组用`printf`输出。`unorder_map`要比`map`容器快，省略的排序操作。

```ruby
#include<iostream>
#include<vector>
#include<string>
#include<unordered_map>
#include<algorithm>
using namespace std;
int N,M;
struct node
{
    int value;
    string id;
};
bool cmp(const node &e1,const node &e2) 
{
    if(e1.value != e2.value)
    {
        return e1.value > e2.value;
    }
    else 
    {
        return e1.id  < e2.id;
    }
}
vector<node> list;
int main()
{
    //首先声明传递参数的定义变量：省略了重复创建次数减少时间，
        int x;
        string ctr;
    
    cin>>N>>M;
    list.resize(N);
    for(int i = 0;i < N;++i)
    {
        cin>>list[i].id>>list[i].value;
    }
    for(int i = 1;i <= M;++i)
    {
      
        cin>>x>>ctr;
        cout<<"Case "<<i<<": "<<x<<" "<<ctr<<endl;
        vector<node> ans;
        if(x == 1)
        {
            for(auto &e : list)
            {
                if(e.id[0] == ctr[0])
                {
                   ans.push_back({e.value,e.id}); 
                }
            }
        }
        else if(x == 2)
        {
            int sum = 0,cnt = 0;
            for(auto &e : list)
            {
               
                if(e.id.substr(1,3) == ctr)
                {
                    sum += e.value;
                    ++cnt;
                }
            }
            if(cnt != 0)
            {
                printf("%d %d\n",cnt,sum);
                continue;
            }
            else 
            {
                printf("NA\n");
                continue;
            }
        }
        else if(x == 3)
        {
            unordered_map<string,int> ms;
            for(auto &e :list)
            {    
                if(e.id.substr(4,6) == ctr)
                {
                    ms[e.id.substr(1,3)]++;
                }
            }
            for(auto &w : ms)
            {
                ans.push_back({w.second,w.first});
            }
        }
        sort(ans.begin(),ans.end(),cmp);
        if(ans.size() == 0)
        {
            cout<<"NA\n";
        }
        else 
        {  
            for(auto &result : ans)
            {
                printf("%s %d\n",result.id.c_str(),result.value);
            }
        }
    }
    return 0;
}
```

### **1150** **Travelling Salesman Problem** **

> 考点：图的存储（这里用邻接矩阵比较方便），理解
>
> 总结：对于遍历每个城市的理解（一种是每个城市走一遍，另一种是循环过程中除了起点外，其他城市出现路过多次）

```ruby
#include<iostream>
#include<vector>
#include<set>
using namespace std;
int N,M,K;
int edge[210][210]={0};
int ans = 1<<30,dissum = 1<<30;
void check(int index)
{
    int cnt;
    cin>>cnt;
    vector<int> v(cnt);
    set<int> st;
    for(int i = 0;i < cnt;++i)
    {
        cin>>v[i];
        st.insert(v[i]);
    }
    bool flag = 1;
    int sum = 0;
    //是否是循环，简单循环，普通循环，不是循环 （输出总的距离）
    for(int i = 0;i < cnt - 1;++i)
    {
        if(edge[v[i]][v[i+1]] == 0)
        {
            flag = 0;
        }
        sum += edge[v[i]][v[i+1]];
    }
    //不存在这种路径
    if(flag == 0)
    {
        printf("Path %d: NA (Not a TS cycle)\n",index);
    }
    else if(v[0] != v[cnt - 1] || st.size() != N)//不是游览每个城市的循环
    {
        printf("Path %d: %d (Not a TS cycle)\n",index,sum);
    }
    else if(cnt != N + 1)//虽然遍历每一个城市，但是有城市走了多次（最佳路径是每个城市只走一次）
    {
        printf("Path %d: %d (TS cycle)\n",index,sum);
        //cout<<"----------n every  cnt != n + 1---------"<<st.size()<<"n --"<<N<<"----\n";
        /*for(int i = 0;i < cnt;++i)
        {
            cout<<v[i]<<' ';
        }
        cout<<endl;*/
        if(ans > sum)
        {
            ans = sum;
            dissum = index;
        }
    }
    else 
    {
        printf("Path %d: %d (TS simple cycle)\n",index,sum);
        if(ans > sum)
        {
            ans = sum;
            dissum = index;
        }
    }
}
int main()
{
    cin>>N>>M;
    for(int i = 0;i < M;++i)
    {
        int x,y,z;
        cin>>x>>y>>z;
        edge[x][y] = edge[y][x] = z;
    }
    cin>>K;
    for(int i = 1;i <= K;++i)
    {
        check(i);
    }
    printf("Shortest Dist(%d) = %d\n",dissum,ans);
    return 0;
}
```

### **1149** **Dangerous Goods Packaging** 

> 考点：容器
>
> 总结：存储每个商品不能共存的商品，遍历每个测试数组，查询每个商品不共存的集合中是否存在在测试数据中（这里用数组cnt标记测试的商品，如果集合中存在测试数据，这组测试就不能通过）。

```ruby
#include<iostream>
#include<unordered_map>
#include<vector>
using namespace std;
int N,M,K;
unordered_map<int,vector<int> > ms;
int main()
{ 
    cin>>N>>M;
    for(int i = 0;i < N;++i)
    {
        int a,b;
        cin>>a>>b;
        ms[a].push_back(b);
        ms[b].push_back(a);
    }
    for(int i = 0;i < M;++i)
    {
        cin>>K;
        int a[100000] = {0};
        vector<int> cnt(K);
        for(int j = 0;j < K;++j)
        {
            cin>>cnt[j];
            a[cnt[j]] = 1;
        }
        bool flag = 1;
        for(int j = 0;j < K;++j)
        {
            for(int d = 0;d < ms[cnt[j]].size();++d)
            {
                if(a[ms[cnt[j]][d]] == 1)
                {
                    flag = 0;
                    break;
                }
            }
        }
        cout<<(flag == 1 ? "Yes\n": "No\n");
    }
    return 0;
}
```

### **1146** **Topological Order** 

> 考点：拓扑排序，图的存储，入度
>
> 总结：

```ruby
#include<iostream>
#include<vector>
using namespace std;
int N,M,K;
vector<vector<int> > G;
vector<int> inr;
int main()
{
    cin>>N>>M;
    G.resize(N+1);
    inr.resize(N+1);
    for(int i = 0;i < M;++i)
    {
        int  x,y;
        cin>>x>>y;
        G[x].push_back(y);
        inr[y]++;
    }
    cin>>K;
    vector<int> ans;
    for(int i = 0;i < K;++i)
    {
        int a;
        bool judge = 1;
        vector<int> intest(inr.begin(),inr.end());
        for(int j = 0;j < N;++j)
        {   
            scanf("%d",&a);
            if(intest[a] != 0)
            {
                judge = 0;
            }
            for(auto &w : G[a])
            {
                intest[w]--;
            }
        }
        if(judge == 1)
        {
            continue;
        }
        ans.push_back(i);
    }
    bool flag = 0;
    for(auto w : ans)
    {
        printf("%s%d",(flag == 1 ? " " : ""),w);
        flag = 1;
    }
    return 0;
}
```

### **1145** **Hashing - Average Search Time** 

> 考点：hash函数：平方探测
>
> 总结：插入时下标从0 到 size - 1	 ，查找时下标为0 到 size  。有问题

```ruby
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
int N,M,Msize,a;
int v[100005] = {0};
bool isPrime(int x)
{
    for(int i = 2;i <= sqrt(x);++i)
    {
        if(x % i == 0)
        {
            return false;
        }
    }
    return true;
}
int main()
{
    scanf("%d %d %d",&Msize,&N,&M);
    while(!isPrime(Msize))
    {
        Msize++;
    }

    for(int i = 0;i < N;++i)
    {
        scanf("%d",&a);
        int flag = 0;
        for(int j = 0;j < Msize;++j)
        {
            int ind = (a + j * j)%Msize;
            if(v[ind] == 0)
            {
                v[ind] = a;
                flag = 1;
                break;
            }
        }
        if(!flag)
            printf("%d cannot be inserted.\n",a);
    }
    int ans = 0;
    for(int i = 0;i < M;++i)
    {
        scanf("%d",&a);
        for(int j = 0;j <= Msize;++j)
        {
            ++ans;
            int ind = (a + j*j)%Msize;
            if(v[ind] == 0 ||v[ind] == a)
                break;
        }
    }
    printf("%.1f\n",(ans*1.0)/M);
    return 0;
}
```

### **1142** **Maximal Clique**

> 考点：图的存储，邻接矩阵
>
> 总结：对于每个测试，利用枚举查找测试数据中是否有不相邻的点，如果都相邻，说明是团。之后对团进行分类（最大，不是最大），方法：首先标记团中的顶点，查找不在团中的顶点，对顶点进行检查，如果存在不在团中的顶点与测试中所有都相邻说明该团不是最大，否则是。

```ruby
#include<iostream>
#include<vector>
#include<unordered_map>
#include<algorithm>
using namespace std;
int N,M,K,Nv,nx;
int edge[220][220] = {0};
int main()
{
    cin>>N>>M;
    for(int i = 0;i < M;++i)
    {
        int x,y;
        cin>>x>>y;
        edge[x][y] = edge[y][x] = 1;
    }
    cin>>K;
    for(int i = 0;i < K;++i)
    {
        cin>>Nv;
        unordered_map<int,int> h;
        vector<int> vs(Nv);
        for(int j = 0;j < Nv;++j)//测试
        {
            cin>>vs[j];
            h[vs[j]] = 1;
        }
        bool adjacent = 1;
        //查找是否是团
        for(int j = 0;j < Nv;++j)
        {
            if(adjacent == 0)break;
            for(int d = j + 1;d < Nv;++d)
            {//测试中有不相邻的
                if(edge[vs[j]][vs[d]] == 0)
                {
                    adjacent = 0;
                    break;
                }
            }
        }
        if(adjacent == 0)
            printf("Not a Clique\n");
        else
        {
            int ans = 0;
            //是团，查看是否为最大
            for(int j = 1;j <= N;++j)//n个顶点
            {
                //查看是否有不相邻
                if(h[j] == 0)
                {
                    int w;
                    for(w = 0;w < vs.size();++w)
                    {
                        if(edge[j][vs[w]] == 0)
                        {
                            break;
                        }
                    }
                    if(w == vs.size())
                        ++ans;
                }
            }
            if(ans)
                printf("Not Maximal\n");
            else 
                 printf("Yes\n");
        }
        
        
    }
    return 0;
}
```

###**1141** **PAT Ranking of Institutions** 

> 考点：排序，计算，排名格式
>
> 总结：学校不区分大小写，tws取整数部分，排名

```ruby
#include<iostream>
#include<vector>
#include<string>
#include<unordered_map>
#include<algorithm>
using namespace std;
int N;
unordered_map<string,int> ScoreA,ScoreB,ScoreT,totalS,TWS,Peo;
struct node
{
    string school;
    int tws;
    int num;
    bool operator<(const node &e)const
    {
        if(tws != e.tws)
        {
            return tws > e.tws;
        }
        else 
        {
            if(num != e.num)
            {
                return num < e.num;
            }
            else 
            {
                return school < e.school;
            }
        }
    }
};
vector<node> ans;
void islowerPro(string &str)
{
    for(int i = 0;i < str.size();++i)
    {
        if(!islower(str[i]))
          str[i] = tolower(str[i]);
    }
}
int main()
{
    scanf("%d",&N);
    for(int i = 0;i < N;++i)
    {
        string sid,School;
        int grade;
       // scanf("%s %d %s",&sid,&grade,&School);
       cin>>sid>>grade>>School;
        islowerPro(School);
      //  cout<<"---School"<<School<<endl;
        //等级
        if(sid[0] == 'A')
        {
            ScoreA[School] += grade;
        }
        else if(sid[0] == 'B')
        {
            ScoreB[School] += grade;
        }
        else if(sid[0] == 'T')
        {
            ScoreT[School] += grade;
        }
        //总分数
        totalS[School] += grade;
        Peo[School]++;
    }
    int sum = 0;
    for(auto &e : Peo)
    {
        sum = ScoreB[e.first]/1.5 + ScoreA[e.first] + ScoreT[e.first]*1.5;
       // cout<<sum<<endl;
        ans.push_back({e.first,sum,Peo[e.first]});
    }
    sort(ans.begin(),ans.end());
    int pre = 1;
    cout<<ans.size()<<endl;
    cout<<pre<<" "<<ans[0].school<<" "<<ans[0].tws<<" "<<ans[0].num<<endl;
    for(int i = 1;i < ans.size();++i)
    {
        if(ans[i].tws == ans[i-1].tws)
        {
            cout<<pre<<" ";
        }
        else 
        {
            cout<<(i+1)<<" ";
            pre = (i+1);
        }
        cout<<ans[i].school<<" "<<ans[i].tws<<" "<<ans[i].num<<endl;
    }
    return 0;
}
```

### **1134** **Vertex Cover**

> 考点：图的存储
>
> 总结：查找图中的所有边是否都有顶点在测试集合中

```ruby
#include<iostream>
#include<vector>
#include<set>
using namespace std;
using pii = pair<int,int>;
int N,M,K,Nv;
vector<pii> ed;
int main()
{
    cin>>N>>M;
    for(int i = 0;i < M;++i)
    {
        int x,y;
        cin>>x>>y;
        if(x > y)
            swap(x,y);
        ed.push_back({x,y});
    }
    cin>>K;
    for(int j = 0;j < K;++j)
    {
        cin>>Nv;
        set<int> v;
        while(Nv--)
        {
            int id;
            cin>>id;
            v.insert(id);
        }
          int ans = 0;
            for(auto &w : ed)
            {
                int nx = w.first,ny = w.second;
                if(v.count(nx)||v.count(ny))
                    ++ans;
            }
            cout<<(ans != M ? "No\n" : "Yes\n");
    }
    return 0;
}
```

### **1133** **Splitting A Linked List** 

> 考点：链表
>
> 总结：按照链表的顺序查找对应类型的数值。各类型按照顺序存入集合，再合并之后输出即可。

```ruby
#include<iostream>
#include<vector>
using namespace std;
const int max_n = 100005;
struct node
{
    int address;
    int data;
    int next;
};
int data[max_n],ntr[max_n];
vector<node> ans;
vector<node> nongit,smallK;
int firstnode,N,K;
int main()
{
    cin>>firstnode>>N>>K;
    for(int i = 0;i < N;++i)
    {
        int f,d,nx;
        cin>>f>>d>>nx;
        data[f] = d;
        ntr[f] = nx;

    }
    while(firstnode != -1)
    {
        int f = firstnode,d = data[f],nx = ntr[f];
        if(d < 0)
        {
            nongit.push_back({f,d,nx});
        }
        else if(d >= 0 && d <= K)
        {
            smallK.push_back({f,d,nx});
        }
        else 
        {
            ans.push_back({f,d,nx});
        }
        firstnode = nx;
    }
    for(auto &w : smallK)
    {
        nongit.push_back(w);
    }
    for(auto &w : ans)
    {
        nongit.push_back(w);
    }
    for(int i = 0;i < nongit.size();++i)
    {
        printf("%05d %d",nongit[i].address,nongit[i].data);
        if(i != nongit.size() - 1)
            printf(" %05d\n",nongit[i+1].address);
        else 
            printf(" -1\n");
    }
    return 0;
}
```

### **1130** **Infix Expression**

> 考点：递归
>
> 总结：重复练习。注意左边数为零可以表示空

```ruby
#include<iostream>
#include<vector>
using namespace std;
struct node
{
    string val;
    int leftl;
    int rightl;
};
int N,root = 1;;
vector<node> te(30);
string dfs(int index)
{
    if(index == -1)
        return "";
    if(te[index].rightl != -1)
    {
        te[index].val = dfs(te[index].leftl) + te[index].val + dfs(te[index].rightl);
        if(index != root)
        te[index].val = "(" + te[index].val + ")";
    }
    return te[index].val;
}
int main()
{
    cin>>N;
    vector<bool> visited(N+1);
    for(int i = 1;i <= N;++i)
    {
        cin>>te[i].val>>te[i].leftl>>te[i].rightl;
        if(te[i].leftl != -1)
            visited[te[i].leftl] = true;
        if(te[i].rightl != -1)
            visited[te[i].rightl] = true;
    }

    while(visited[root] == true)
        root++;
    cout<<dfs(root)<<endl;

    return 0;
}
```

### **1129** **Recommendation System**

> 考点：模拟题，排序
>
> 总结：输出此类商品编号和之前访问最多的前K个编号（如果编号出现次数相同则按照编号的升序排序）

```ruby
#include<iostream>
#include<set>
#include<algorithm>
using namespace std;

const int max_n = 100005;
int  N,K;
struct node
{
    int  value;
    int cnt;
    bool operator<(const node &e)const
    {
        if(cnt != e.cnt)
        {
            return cnt > e.cnt;
        }
        else 
        {
            return value < e.value;
        }
    }
};
int idnum[max_n] = {0};
int main()
{
    cin>>N>>K;
    int num;
    set<node> st;
    for(int i = 0;i < N;++i)
    {
        scanf("%d",&num);
        if(i != 0)
        {
            printf("%d:",num);
            int testnum = 1;
            for(auto it = st.begin();it != st.end() && testnum <= K;++it)
            {
                cout<<" "<<it->value;
                ++testnum;
            }
            printf("\n");
        }
        auto it = st.find({num,idnum[num]});
        if(it != st.end())
            st.erase(it);
        st.insert({num,++idnum[num]});
    }
    return 0;
}
```

###**1126** **Eulerian Path** 

> 考点：图
>
> 总结：欧拉回路：连通并且每个点的度为偶数。

```ruby
#include<iostream>
#include<vector>
#include<numeric>
#include<algorithm>
using namespace std;

const int max_n = 100005;

vector<vector<int> > G;
int pre[max_n];
int N,M,cnt = 0;
int find(int x)
{
    return pre[x] == x ? x : find(pre[x]);
}
void un(int x,int y)
{
    int nx = find(x),ny = find(y);

    if(nx == ny)
        return ;
    ++cnt;
    pre[nx] = ny;
}
void solve()
{
    int ans =  0,odd = 0;
    for(int i = 1;i <= N;++i)
    {
        if(G[i].size() % 2 == 0)
            ++ans;
        else 
            ++odd;
        cout<<G[i].size()<<(i != N ? " " : "\n");
    }
    if((cnt == N - 1)&&(ans == N))
    {
        cout<<"Eulerian\n";
    }
    else if(odd == 2 && ans + odd == N && cnt == N-1)
    {
        cout<<"Semi-Eulerian\n";
    }
    else 
    {
        cout<<"Non-Eulerian\n";
    }
}
int main()
{
    iota(pre,pre + max_n,0);
    cin>>N>>M;
    G.resize(N+1);

    for(int i = 0;i < M;++i)
    {
        int x,y;
        cin>>x>>y;
        un(x,y);
        G[x].push_back(y);
        G[y].push_back(x);
    }
    solve();
    return 0;
}
```

###**1125** **Chain the Ropes** 

> 考点：小贪心
>
> 总结：每次串联要使得两个绳子的长度之和减半，为了让最长的绳子减少折叠，排序之后进行计算。从前向后折叠。

```ruby
#include<iostream>
#include<cmath>
#include<algorithm>
#include<vector>
using namespace std;

vector<int> st;
int N;
int main()
{
    cin>>N;
    int t;
    for(int i = 0;i < N;++i)
    {
        cin>>t;
        st.push_back(t);
    }
    sort(st.begin(),st.end());
    int result = st[0];
    for(int i = 1;i < N;++i)
        result  = (result + st[i])/2;
    cout<<result<<endl;
    return 0;
}
```

###**1122** **Hamiltonian Cycle**

> 考点：图的存储，循环
>
> 总结：测试数组是循环；没有不存在的路径；正好走了一圈（除去起点外，没有其他顶点走多次）；每个顶点都路过。



```ruby
#include<iostream>
#include<cmath>
#include<algorithm>
#include<vector>
#include<set>
using namespace std;

const int max_n = 10005;
int edge[max_n][max_n] = {0};
int N,M,K;
int main()
{
    cin>>N>>M;
    for(int i = 0;i < M;++i)
    {
        int x,y;
        cin>>x>>y;
        edge[x][y] = edge[y][x] = 1;
    }
    cin>>K;
    while(K--)
    {
        int nv;
        cin>>nv;
        vector<int> test(nv);
        set<int> st;
        for(int i = 0;i < nv;++i)
        {
            cin>>test[i];
            st.insert(test[i]);
        }
        //包含每个顶点的简单循环
        int cnt = 0;
        bool flag = true;
        for(int i = 1;i < nv;++i)
        {
            if(edge[test[i - 1]][test[i]] == 0)
            {
                flag = false;//有断路
                break;
            }
            ++cnt;
        }
        if((test[0] == test[nv - 1])&&(st.size() == N)&&flag&&(cnt == N))
        {
            cout<<"YES\n";
        }
        else 
        {
            cout<<"NO\n";
        }
    }
    return 0;
}
```

###**1121** **Damn Single** 

> 考点：
>
> 总结：防止超时，利用map集合存储对应的夫妻（这里利用数组会超出容量），输入测试样例的过程中存在夫妻则将其夫妻删除并且跳过这次id

```ruby
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<vector>
#include<set>
#include<unordered_set>
#include<unordered_map>
using namespace std;

const int max_n = 100005;
int N,K;
unordered_map<int,int> couple;

int main()
{
    cin>>N;
    for(int i = 0;i < N;++i)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        couple[x] = y;
        couple[y] = x;
    }
    cin>>K;
    set<int> testees;
    for(int i = 0;i < K;++i)
    {
        int id;
        cin>>id;
       
        if(couple.count(id))
        {
            int couid = couple[id];//是否有配对的
            if(testees.count(couid))
            {
                testees.erase(couple[id]);
                continue;;
            }

        }
        testees.insert(id);
    }
    int nx = testees.size();
    cout<<nx<<endl;
    for(auto &w : testees)
    {
        printf("%05d%s",w,(--nx ? " " : "\n"));
    }

    return 0;
}
```

### **1118** **Birds in Forest** 

> 考点：并查集
>
> 总结：

```ruby
#include<iostream>
#include<vector>
#include<numeric>
#include<unordered_set>
using namespace std;

const int max_birds = 10005;
int N,K,cnt;
int pre[max_birds];
unordered_set<int> birds;
int find(int x)
{
    return pre[x] == x ? x : find(pre[x]);
}
void un(int x,int y)
{
    int nx = find(x), ny = find(y);
    if(nx == ny)
        return;
    if(nx < ny)
        pre[ny] = nx;
    else 
        pre[nx] = ny;
    ++cnt;
}
int main()
{
    iota(pre,pre + max_birds,0);
    cin>>N;
    for(int i = 0;i < N;++i)
    {
        cin>>K;
        K--;
        int t;
        cin>>t;
        birds.insert(t);
        while (K--)
        {
            int id;
            cin>>id;
            birds.insert(id);
            un(t,id);
        }
    }
    int Q;
    cin>>Q;
    int num = birds.size();
    cout<<(num - cnt)<<" "<<num<<endl;
    for(int i = 0;i < Q;++i)
    {
        int x,y;
        cin>>x>>y;
        if(find(x) == find(y))
            cout<<"Yes\n";
        else 
            cout<<"No\n";
    }
    return 0;
}
```

###**1117** **Eddington Number** 

> 考点：贪心算法
>
> 总结：从大到小排序，大于等于st 英里的天数 i + 1天（i为下标），则有`st - 1 >= i + 1`有`i+1`天，必须使得超过英里数`st[i] - 1 大于等于天数 i + 1 `即`st[i] - 1 >= i + 1`也就是`st[i] >= i + 2`也就是`st[i] > i + 1`。从前向后天数逐渐增加，英里逐渐减少。

```ruby
#include<iostream>
#include<vector>
#include<numeric>
#include<unordered_set>
#include<algorithm>

using namespace std;

int n;
bool cmp(const int &e1,const int &e2)
{
    return e1 > e2;
};
int main()
{
    cin>>n;
    vector<int> st(n);
    for(int i = 0;i < n;++i)
        cin>>st[i];
    sort(st.begin(),st.end(),cmp);
    int max_n = 0;
    while (max_n < n && st[max_n] > max_n + 1)
        max_n++;
    
    
    cout<<max_n<<endl;
    return 0;
}
```

###**1114** **Family Property**

> 考点：并查集
>
> 总结：注意对应家庭的总人数的计算（不要重复计算），数组下标的范围.

```ruby
#include<iostream>
#include<vector>
#include<set>
#include<numeric>
#include<algorithm>

using namespace std;

const int max_n = 10005;
struct node
{
    int id;
    int fa,ma;
    int k;
    int childs[10] = {0};
    int Mestate;
    int area;
};
struct te
{
    int id;
    int peoples;
    int houses;
    double totalAreas;
};
struct anse
{
    int id;
    int nu;
    double avese;
    double avearrr;
    bool operator<(anse &e)const 
    {
        if(avearrr != e.avearrr)
            return avearrr > e.avearrr;
        else
        {
            return id < e.id;
        }
        
    }
};
int N;
vector<node> list(max_n);
int pre[max_n];
int find(int x)
{
    return x == pre[x] ? x : find(pre[x]);
}
void un(int x,int y)
{
    int nx = find(x),ny = find(y);
    if(nx <= ny)
        pre[ny] = nx;
    else 
        pre[nx] = ny;
}
int main()
{
    iota(pre,pre + max_n,0);
    cin>>N;

    for(int i = 0;i < N;++i)
    {
        cin>>list[i].id>>list[i].fa>>list[i].ma>>list[i].k;

        if(list[i].fa != -1)
            un(list[i].id,list[i].fa);
        if(list[i].ma != -1)
            un(list[i].id,list[i].ma);
        for(int j = 0;j < list[i].k;++j)
        {
            cin>>list[i].childs[j];
            un(list[i].id,list[i].childs[j]);

        }
        cin>>list[i].Mestate;
        cin>>list[i].area;
    }
    vector<te> test(max_n);
    for(int i = 0;i < max_n;++i)
    {
        int mind = find(i);
        
        test[mind].id = mind;
        test[mind].peoples++;
    }

    set<int> familys;
    for(int i = 0;i < N;++i)
    {
        int mid = find(list[i].id);

        familys.insert(mid);
        test[mid].id = mid;
        test[mid].houses += list[i].Mestate;

        
        test[mid].totalAreas += list[i].area;
    }

    vector<anse> result;
    for(auto &w : familys)
    {
        int id = test[w].id,nums = test[w].peoples;
        double avfsets = test[w].houses/(nums*1.0);
        double avearea = test[w].totalAreas/(nums*1.0);
        result.push_back({id,nums,avfsets,avearea});
    }
    sort(result.begin(),result.end());
    cout<<result.size()<<endl;
    for(auto &e : result)
    {
        printf("%04d %d %.3f %.3f\n",e.id,e.nu,e.avese,e.avearrr);
    }

    return 0;
}
```

### **1113** **Integer Set Partition**

> 考点：贪心算法
>
> 总结：排序后，平分区间，大数尽可能多。

```ruby
#include<iostream>
#include<vector>
#include<set>
#include<numeric>
#include<algorithm>

using namespace std;

const int max_n = 10005;

int n1, n2;
int N;
int main()
{
    cin>>N;
    vector<int> st(N);
    int sum = 0;
    for(int i = 0;i < N;++i)
    {
        cin>>st[i];
        sum += st[i];
    }
    sort(st.begin(),st.end());
    
    n1 = N/2;
    n2 = N - n1;
    int sum2 = 0;
    for(int i = 0;i < n1;++i)
    {
        sum2 += st[i];
    } 
    printf("%d %d",n2 - n1,sum - sum2 - sum2);  
    return 0;
}
```

### **1110** **Complete Binary Tree**

> 考点：递归，二叉树的层次遍历，完全二叉树
>
> 总结：

```ruby
#include<iostream>
#include<vector>
#include<set>
#include<queue>
#include<cstring>
#include<algorithm>

using namespace std;

const int max_n = 100005;
struct node
{
    int leftn;
    int rightn;
}a[max_n];
int pre[max_n],N,root = 0,max_index = -1 , ans;
void dfs(int x,int y)
{
    if(x == -1)
        return;
    if(max_index < y)
    {
        max_index = y;
        ans = x;
    }

    dfs(a[x].leftn,2 * y + 1);
    dfs(a[x].rightn,2 * y + 2);
}
int main()
{
    memset(pre,-1,sizeof(pre));
    cin>>N;
    for(int i = 0; i < N;i++)
    {
        string l,r;
        cin>>l>>r;
        if(l == "-")
            a[i].leftn = -1;
        else 
            a[i].leftn = stoi(l),pre[stoi(l)] = i;
        if(r == "-")
            a[i].rightn = -1;
        else 
            a[i].rightn = stoi(r),pre[stoi(r)] = i;
    }
    while(pre[root] != -1)
        root++;

    dfs(root,0);
    if(max_index == N - 1)
    {
        cout<<"YES "<<ans<<endl;
    }
    else 
    {
        cout<<"NO "<<root<<endl;
    }
    return 0;
}
```

### **1109** **Group Photo** 

> 考点：数组
>
> 总结：首先输出最后一行（即`N - (N/K)*(K-1)`总的人数减去前面`k-1`行的人数）。对于每一行，以最高的人的下标为分界，首先填入下标左面的元素（即照片中人的右侧）隔一个人取一个，右面同理。即将人的信息以身高的降序排列，身高相同按照姓名的字典序排列，然后从后向前打印姓名。

```ruby
#include<iostream>
#include<vector>
#include<algorithm>
#include<string>

using namespace std;
struct node
{
    int height;
    string name;
    //在每一行中，其他人必须按照其身高降序进入，交替地将它们的位置先移到最高人的右侧
    //，然后再移动至左侧，身高相同时，必须按姓名的字母顺序（递增）进行排序。
    bool operator<(const node &e)const
    {
        if(height != e.height)
            return height > e.height;
        else 
            return name < e.name;
    }
};

int N,K;
int main()
{
    cin>>N>>K;
    vector<node> list(N);
    for(int i = 0;i < N;++i)
    {
        cin>>list[i].name>>list[i].height;
    }
    sort(list.begin(),list.end());

    int row = K,rmove = 0,CountPeo;
    while(row)
    {
        if(row == K)
        {
            CountPeo = N - (N/K)*(K-1);
        }
        else 
        {
            CountPeo = N/K;
        }

        vector<string> ans(CountPeo);//当行的人数
        ans[CountPeo/2] = list[rmove].name;//最高的
        int j = CountPeo/2 - 1;
        //左侧（相当于照片中人的右侧）
        for(int i = rmove + 1;i < rmove + CountPeo;i += 2)
        {
            ans[j--] = list[i].name;
        }
        j = CountPeo/2 + 1;
        for(int i = rmove + 2;i < rmove + CountPeo;i += 2)
        {
            ans[j++] = list[i].name;
        }

        cout<<ans[0];
        for(int i = 1;i < CountPeo;++i)
            cout<<" "<<ans[i];
        cout<<endl;
        row--;
        rmove += CountPeo;
    }
    return 0;
}
```

###**1106** **Lowest Price in Supply Chain** 

> 考点：二叉树的遍历，递归
>
> 总结：题目问的是叶子节点的最小值以及个数。

```ruby
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;
int N,K;
vector<vector<int> > ans;
vector<bool> visited;
double P,r;
double minP = 0x3f3f3f3f;
int cnt = 0;
void dfs(int x,double price)
{   
    visited[x] = true;
   if(ans[x].size() == 0)//题目问的是叶子节点的权值最小的有几个
   /// cout<<x<<"=========="<<price<<endl;
    if(price < minP)
    {
        cnt  = 0;
        minP = price;
        cnt++;
    }
    else if(price == minP)
    {
        cnt++;
    }
    for(auto &w : ans[x])
    {
        if(!visited[w])
            dfs(w,price*(1+r*0.01));
    }
}
int main()
{
    cin>>N>>P>>r;

    visited.resize(N);
    ans.resize(N);

    fill(visited.begin(),visited.end(),false);
    for(int i = 0;i < N;++i)
    {
        cin>>K;
        for(int j = 0;j < K;++j)
        {
            int distributors;
            cin>>distributors;
            ans[i].push_back(distributors);
        }
    }
    dfs(0,P);
    printf("%.4f %d",minP,cnt);
    return 0;
}
```

### **1105** **Spiral Matrix** 

> 考点：数组（蛇形矩阵）
>
> 总结：蛇形矩阵模板

```ruby
#include<iostream>
#include<vector>
#include<cstring>
#include<cmath>
#include<algorithm>

using namespace std;

const int max_n  = 104;

int dx[4] = {0,1,0,-1}, dy[4] = {1,0,-1,0};
int N;
bool cmp(int a,int b)
{
    return a > b;
}
int result[max_n][max_n],n,m;
int main()
{
    memset(result,-1,sizeof(result));

    cin>>N;
    vector<int> ans(N);
    for(int i = 0;i < N;++i)
    {
        cin>>ans[i];
    }
    sort(ans.begin(),ans.end(),cmp);
    for(int i = sqrt(N);i >= 1;--i)
    {
        if(N % i == 0)
        {
            n = i;
            m = N / i;
            break;
        }
    }
    int cnt = 0;
    int x = 0,y = 0,d = 0;
    while(cnt < N)
    {
        result[x][y] = ans[cnt++];
        
        int a = x + dx[d] , b = y + dy[d];

        if(a >= m || a < 0 || b >= n || b < 0 || result[a][b] != -1)
        {
            d = (d + 1)%4;
            a = x + dx[d], b = y + dy[d];
        }
        
        x = a, y = b;
    }

   for(int i = 0;i < m;++i)
   {
       for(int j = 0;j < n;++j)
        cout<<result[i][j]<<(j != n - 1 ? " " : "\n");
   }
    return 0;
}
```

### **1102** **Invert a Binary Tree**

> 考点：二叉树的遍历，层序遍历，中序遍历
>
> 总结：反转后的性质。层序遍历是根据（同一层）反转或者不翻转后的index下标的大小进行的。

```ruby
#include<iostream>
#include<vector>
#include<algorithm>
#include<unordered_map>

using namespace std;
struct node
{
    int id;
    int leftn;
    int rightn;
    int index;
    int level;
    bool operator<(const node & e)const 
    {
        if(level != e.level)
        {
            return level < e.level;
        }
        else 
        {//这里如果排序顺序是根据 2*index + 1 和 2*index + 2在dfs右结点还是左节点进行的
            return index > e.index;
        }
    }
};
unordered_map<int,int> ms;
vector<node> v1,v2;
void dfs(int x,int index,int deep)
{
    if(v1[x].rightn != -1)
        dfs(v1[x].rightn,2*index + 2,deep + 1);
    v2.push_back({x,0,0,index,deep});//中序遍历
    if(v1[x].leftn != -1)
        dfs(v1[x].leftn,2*index + 1,deep + 1);
}
int N,root = 0;
int main()
{
    cin>>N;
    v1.resize(N);
    for(int i = 0;i < N;++i)
    {
        char x,y;
        cin>>x>>y;
        if(x != '-')
            v1[i].leftn = (x - '0'),ms[(x - '0')] = i;
        else 
            v1[i].leftn = -1;
        if(y != '-')
            v1[i].rightn = (y - '0'),ms[(y - '0')] = i;
        else 
            v1[i].rightn = -1;
    }
    while(ms.count(root))
        root++;
    dfs(root,0,1);

    vector<node> v3(v2);
    //层序遍历，按照层数排序，层数相同按照index降序排列
    sort(v3.begin(),v3.end());

    for(int i = 0;i < v3.size();++i)
        cout<<v3[i].id<<(i != v3.size() - 1 ? " " : "\n");
    
    for(int i = 0;i < v2.size();++i)
        cout<<v2[i].id<<(i != v2.size() - 1 ? " " : "\n");

    return 0;
}
```

### **1097** **Deduplication on a Linked List**

> 考点：链表
>
> 总结：注意格式，尾节点。

```ruby
#include<iostream>
#include<cmath>
#include<vector>
#include<set>

using namespace std;
const int max_node = 100005;

struct node
{
    int address;
    int data;
    int next;
};
int htr, n,data[max_node],ntr[max_node];
vector<node> ans,rem;
int main()
{
    cin>>htr>>n;
    for(int i = 0;i < n;++i)
    {
        int a,b,c;
        cin>>a>>b>>c;
        ntr[a] = c;
        data[a] = b;
    }
    int rt = htr;
    set<int> st;
    while(rt != -1)
    {
        if(!st.count(abs(data[rt])))
            ans.push_back({rt,data[rt],ntr[rt]}),st.insert(abs(data[rt]));
        else 
            rem.push_back({rt,data[rt],ntr[rt]});
        rt = ntr[rt];
    }
    if(ans.size() != 0)
    {
        printf("%05d %d",ans[0].address,ans[0].data);
        if(ans.size() == 1)
            printf(" -1\n");
        else 
        {
            printf(" %05d\n",ans[1].address);
            for(int i = 1;i < ans.size();++i)
            {
                printf("%05d %d",ans[i].address,ans[i].data);
                if(i != ans.size() - 1)
                    printf(" %05d\n",ans[i + 1].address);
                else 
                    printf(" -1\n");
            }
        }
    }

    if(rem.size() != 0)
    {
        printf("%05d %d",rem[0].address,rem[0].data);
        if(rem.size() == 1)
            printf(" -1\n");
        else 
        {
            printf(" %05d\n",rem[1].address);
            for(int i = 1;i < rem.size();++i)
            {
                printf("%05d %d",rem[i].address,rem[i].data);
                if(i != rem.size() - 1)
                    printf(" %05d\n",rem[i + 1].address);
                else 
                    printf(" -1\n");
            }
        }
    }

    return 0;
}
```

### **1096** **Consecutive Factors** 

> 考点：枚举，特殊情况
>
> 总结：对于素数的判断（输出本身）

```ruby
#include<iostream>
#include<cmath>
#include<vector>
#include<set>

using namespace std;
const int max_node = 100005;

int main()
{
    int n;
    cin>>n;
    int cnt = 0,max_n = 0,index = n;
    bool flag = false;
    for(int i = 2;i <= sqrt(n);++i)
    {
        int  tn = n;
        if(tn % i == 0)
        {
            flag = true;
            cnt = 0;
            int x = i;
            while(tn&&(tn%x == 0))
            {
                tn /= (x++);
                cnt++;
            }

            if((max_n < cnt))
            {
                max_n = cnt;
                index = i;
            }
        }
    }
    if(max_n == 0)
    {
        printf("1\n");
        cout<<n<<endl;
        return 0;
    }
    cout<<max_n<<endl;
    
    for(int i = 0;i < max_n;++i)
    {
        cout<<(index + i)<<(i != max_n - 1 ? "*" : "\n");
    }
    return 0;
}
```

### **1094** **The Largest Generation**

> 考点：树的遍历，计数
>
> 总结：利用数组记录对应层数的人数，取最大人数并标记对应的层数即可。

```ruby
#include<iostream>
#include<cmath>
#include<vector>
#include<set>

using namespace std;
using pii = pair<int,int>;
const int max_node = 100005;

int N,M;
vector<vector<int> > ans;
vector<bool> visited;
int ts[max_node] = {0},cnt = 0,max_deep = 0;
void dfs(int x,int deep)
{
    
    visited[x] = true;
    ts[deep]++;
    if(ts[deep] > cnt)
    {
        cnt = ts[deep];
        max_deep = deep;
    }

    for(auto &w : ans[x])
    {
        if(!visited[w])
        {
            dfs(w,deep + 1);
        }
    }
}
int main()
{
    cin>>N>>M;
    ans.resize(N+1);
    visited.resize(N+1);
    fill(visited.begin(),visited.end(),false);
    for(int i = 0;i < M;++i)
    {
        int x;
        cin>>x;
        int t;
        cin>>t;
        while(t--)
        {
            int y;
            cin>>y;
            ans[x].push_back(y);
        }
    }
    dfs(1,1);
    cout<<cnt<<" "<<max_deep<<endl;
    return 0;
}
 
```

### **1093** **Count PAT's**

> 考点：取余，计算问题
>
> 总结：对应`PAT`字符串的个数为字符`A`左边`P`的个数乘上右边`T`的个数。题目要求对大数取余。

```ruby
#include<iostream>
#include<cmath>
#include<vector>
#include<set>

using namespace std;
using pii = pair<int,int>;

int main()
{
    string str;
    getline(cin,str);
    int cntT = 0,ans = 0, cntA = 0,cntP = 0;;
    for(int i = 0;i < str.size();++i)
        if(str[i] == 'T')
            ++cntT;

    for(int i = 0;i < str.size();++i)
    {
        if(str[i] == 'P')cntP++;
   
        if(str[i] == 'T')cntT--;
        if(str[i] == 'A')
                ans = (ans + cntP*cntT)%1000000007;
    }
    cout<<ans<<endl;
    return 0;
}
```

### **1092** **To Buy or Not to Buy**

> 考点：字符串
>
> 总结：对主串出现的字符进行计数。

```ruby
#include<iostream>
#include<string>
#include<vector>
#include<unordered_map>

using namespace std;

int main()
{
    string str,ctr;
    getline(cin,str);
    getline(cin,ctr);
    unordered_map<char,int> st;
    for(int i = 0;i < str.size();++i)
            st[str[i]]++;
    int len = int(str.size()),ans = 0;
    for(int i = 0;i < ctr.size();++i)
    {
        if(st[ctr[i]] > 0)
        {
            st[ctr[i]]--;
            len--;
        }
        else 
        {
            ++ans;
        }
    }
    if(ans == 0)
    {
        cout<<"Yes "<<len<<endl;
    }
    else 
    {
        cout<<"No "<<ans<<endl;
    }
    return 0;
}
```

###**1090** **Highest Price in Supply Chain**

> 考点：树的遍历，dfs，特别注意dfs过程中的参数传递是否正确
>
> 总结：注意P是根给出的价格（不用加价给购买者，其他购买者需要将价格增加卖给别人)。

```ruby
#include<iostream>
#include<string>
#include<vector>
#include<unordered_map>

using namespace std;

vector<vector<int> > ans;
int N,root;
double p,r,max_price = 0;
vector<bool> visited;
unordered_map<double,int> pnum;
void dfs(int x,double deep)
{
    visited[x] = true;

    if(max_price <= deep)
    {
        max_price = deep;
         pnum[max_price]++;
    }
    
    for(auto &w : ans[x])
    {
        if(!visited[w])
            dfs(w,deep*(1 + r*0.01));
    }
}
int main()
{
    cin>>N>>p>>r;
    ans.resize(N);
    visited.resize(N);
    fill(visited.begin(),visited.end(),false);
    for(int i = 0;i < N;++i)
    {
        int pre;
        cin>>pre;
        if(pre == -1)
            root = i;
        else 
            ans[pre].push_back(i);
    }

    dfs(root,p);
    printf("%.2f %d",max_price,pnum[max_price]);
    return 0;
}
```

### **1089** **Insert or Merge** 

> 考点：插入排序，归并排序
>
> 总结：归并排序可以通过循环来实现

```ruby
#include<iostream>

#include<vector>
#include<algorithm>

using namespace std;
int N;
int a[110],b[110];
int main()
{
    int i,j;
    cin>>N;
    for(int i = 0;i < N;++i)
        cin>>a[i];
    for(int i = 0;i < N;++i)
        cin>>b[i];
    for(i = 0;i < N - 1 && b[i] <= b[i+1];i++);
    for(j = i + 1; a[j] == b[j] && j < N;++j);
    if(j == N)
    {
        cout<<"Insertion Sort"<<endl;
        sort(a,a + i + 2);
    }
    else
    {
        cout<<"Merge Sort"<<endl;
        int k = 1,flag = 1;//第一次归并为两个数字
        while(flag)
        {
            flag = 0;
            for(i = 0;i < N;++i)//从初始状态归并到与b数组相同后，在归并一次
            {
                if(a[i] != b[i])
                    flag = 1;
            }
            k = k * 2;
            for(i = 0;i < N/k;i++)
                sort(a + i * k,a + (i + 1)*k);
            sort(a + N/k * k, a + N);
        }
    }
    for(j = 0;j < N;++j)
        cout<<a[j]<<(j != N - 1 ? " " : "\n");

    return 0;
}

```

### **1088** **Rational Arithmetic** 

> 考点：模拟计算器，求最大公因子
>
> 总结：注意数据范围

```ruby
#include<iostream>
#include<cmath>

using namespace std;
long long a,b,c,d;
long long gcd(long long t1,long long t2)
{
    return t2 == 0 ? t1 : gcd(t2,t1 % t2);
}
void func(long long m,long long n)
{
    if(n * m == 0)
    {
        printf("%s",n == 0 ? "Inf" : "0");
        return ;
    }

    bool flag = ((m < 0 && n > 0) || (m > 0 && n < 0));

    m = abs(m),n = abs(n);
    long long x = m / n;
    printf("%s",flag ? "(-" : "");
    if(x != 0)
        printf("%lld",x);
    if(m % n == 0)
    {
        if(flag)
            printf(")");
        return ;
    }
    if(x != 0)
        printf(" ");
    m = m - x * n;
    long long t = gcd(m,n);
    m = m/t; n = n / t;
    printf("%lld/%lld%s",m,n,flag ? ")" : "");
}
int main()
{
    scanf("%lld/%lld %lld/%lld",&a,&b,&c,&d);
    func(a,b);printf(" + ");func(c,d);printf(" = ");func(a*d + b *c ,b*d);printf("\n");
    func(a,b);printf(" - ");func(c,d);printf(" = ");func(a*d - b *c ,b*d);printf("\n");
    func(a,b);printf(" * ");func(c,d);printf(" = ");func(a*c ,b*d);printf("\n");
    func(a,b);printf(" / ");func(c,d);printf(" = ");func(a*d,b*c);
    return 0;
}

```

### **1086** **Tree Traversals Again**

> 考点：二叉树的遍历
>
> 总结：栈实现的是二叉树的中序遍历，则每次入栈的顺序为二叉树的前序遍历。因此题目就变成直到前序和中序结果求后序遍历的过程。利用递归操作，先递归到的结点最后存储即可得到后序序列。

```ruby
#include<iostream>
#include<vector>
#include<stack>

using namespace std;
//入栈为前序遍历，出栈为中序
vector<int> pre,in,orde;
int N;
stack<int> st;
void solve(int root,int start,int end)
{
    if(start > end)
        return;
    int x = pre[root];

    int i = start;
    //得到中序遍历的根结点
    while(i <= end &&in[i] != x)
        ++i;
    solve(root + 1,start,i - 1);
    solve(root + (i - start) + 1,i + 1,end);
    orde.push_back(x);
}
int main()
{
    cin>>N;
    string str;
    int id;
    while(cin>>str)
    {
        if(str == "Push")
        {
            cin>>id;
            st.push(id);
            pre.push_back(id);
        }
        else 
        {
            in.push_back(st.top());
            st.pop();
        }
    }
    solve(0,0,N-1);
    for(int i = 0;i < N;++i)
        cout<<orde[i]<<(i != N-1 ? " " : "\n");
    return 0;
}
```

### **1085** **Perfect Sequence**

> 考点：贪心算法
>
> 总结：从最小的向后开始枚举长度，过程中忽略比当前长度小的情况

```ruby
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

int N;
long long p;
vector<int> ans;
int main()
{
    cin>>N>>p;
    ans.resize(N);
    for(int i = 0;i < N;++i)
        cin>>ans[i];
    sort(ans.begin(),ans.end());
    int result = 0,temp = 0;
    for(int i = 0;i < N;++i)
    {
        for(int j = i + result ;j < N;++j)
        {
            if(ans[j] <= ans[i] * p)
            {
                temp = j - i + 1;
                if(temp > result)
                {
                    result = temp;
                }
            }
            else 
            {
                break;//第一个不符合条件后面的就更不符合了
            }
        }
    }
    cout<<result<<endl;

    
    return 0;
}
```

### **1084** **Broken Keyboard** 

> 考点：字符串
>
> 总结：标记存在的字符

```ruby
#include<iostream>
#include<vector>
#include<string>
#include<unordered_set>
#include<algorithm>

using namespace std;

unordered_set<char> st;
int main()
{
    string str;
    getline(cin,str);
    string ctr;
    getline(cin,ctr);
    for(auto &c : ctr)
    {
        char x = (isalpha(c) ? toupper(c) : c);
        st.insert(x);
    }
    for(auto &c : str)
    {
        char x = (isalpha(c) ? toupper(c) : c);
        if(!st.count(x))
        {
            st.insert(x);
            cout<<x;
        }
    }
    
    return 0;
}
```

### **1083** **List Grades** 

> 考点：简单排序
>
> 总结：

```ruby
#include<iostream>
#include<vector>
#include<string>
#include<unordered_set>
#include<algorithm>

using namespace std;

struct node
{
    string name,id;
    int grade;
    bool operator<(const node &e)const
    {
        return grade > e.grade;
    }
};
vector<node> ans;
int main()
{
    int N;
    cin>>N;
    ans.resize(N);
    for(int i = 0;i < N;++i)
    {
        cin>>ans[i].name>>ans[i].id>>ans[i].grade;
    }
    int st,ed;
    cin>>st>>ed;
    sort(ans.begin(),ans.end());
    int  cnt = 0;
    for(auto &w : ans)
    {
        int tn = w.grade;
        if(w.grade >= st && w.grade <= ed)
        {
            cout<<w.name<<" "<<w.id<<endl;
            ++cnt;
        }
    }
    if(cnt == 0)
    {
        cout<<"NONE"<<endl;
    }
    return 0;
}
```

### **1082** **Read Number in Chinese**

> 考点：字符串模拟
>
> 总结：亿，万，个位的前一个零不需要读出。记录连续零的个数。亿，万是必须要读出的。

```ruby
#include <string>
#include <vector>
#include <iostream>
using namespace std;
int main()
{
    //注意100101的情况，在亿或者万之后出现的0需要ling，在亿和万之间或万和各位之内的数字之间的0也需要ling

 string a[] = { "ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu" };//存放数字对应的字符串
 string b[] = { "", "Shi", "Bai", "Qian", "Wan", "Shi", "Bai", "Qian", "Yi" };//存放位对应的字符串，称作位标识符吧
 vector<string> res;//存放字符串：包括位标示符和其位上的数字
 vector<int> digit;//存放各个位上数字
 int num, e;
 cin >> num;
 
 if(num == 0)
 {
     cout<<"ling";
     return 0;
 }
 else if(num < 0)
 {
     cout<<"Fu ";
     num  =  0 - num;;
 }

 while(num != 0)
 {
     digit.push_back(num%10);
     num /= 10;
 }

 for(e = 0;e < digit.size() && digit[e] == 0;++e);
 for(int i = e;i < digit.size();++i)
 {
     if(i!= 0 &&(digit[i] != 0 || i == 4 || i == 8))//如果不是个位；位上的数字不是0；是万位或亿位，则放入位标识符
     {
         res.push_back(b[i]);
     }
     res.push_back(a[digit[i]]);//放入数字
 }
 for(int i = res.size() - 1;i >= 0;--i)
 {
     if(i != res.size() - 1)
     {
         cout<<" ";
     }
     int cnt = 0;
     while(i >= 0 && res[i] == "ling")
    {
        --i;
        ++cnt;//统计连续的0的个数，注意这里万左右的0是不算连续的，
    }
    if(cnt != 0 && res[i] != "Wan")
    {
        cout<<"ling ";
    }
    cout<<res[i];
 }
  
 return 0;
}
```

### **1081** **Rational Sum** 

> 考点：最大公因数
>
> 总结：注意测试数值的范围，输出格式：零、一个数字（整数或者分式）、两个数字（整数和分式）

```ruby
#include<iostream>
#include<cmath>

using namespace std;

long long gdc(long long t1,long long t2)
{
    return t2 == 0 ? t1 : gdc(t2,t1 % t2);
}

int main()
{
    int N;
    cin>>N;
    long long numera,denomin,t;
    scanf("%lld/%lld",&numera,&denomin);
    t = gdc(abs(numera),abs(denomin));
    numera /= t;
    denomin /= t;
    for(int i = 1;i < N;++i)
    {
        long long  a,b;
        scanf("%lld/%lld",&a,&b);
        t = gdc(abs(a),abs(b));
        a /= t;
        b /= t;
        numera = numera * b + denomin * a;
        denomin = denomin * b;

        t = gdc(abs(numera),abs(denomin));
        numera /= t;
        denomin /= t;
    }
    if(!numera)
    {
        cout<<"0";
        return 0;
    }

    if(numera/denomin)
    {
        cout<<numera/denomin;
        if(numera % denomin != 0)
            cout<<" ";
    }
    
 
    if(numera % denomin)
            cout<<(numera%denomin)<<"/"<<denomin;
   
    return 0;
}

```

### **1079** **Total Sales of Supply Chain**

> 考点：深度，广度，递归
>
> 总结：



```ruby
#include<iostream>
#include<cmath>
#include<cstring>
#include<vector>
#include<algorithm>


using namespace std;

const int max_n = 100005;
vector<vector<int> > ans;
vector<bool> visited;
int totalCount[max_n] = {0};
int pre[max_n];
int N,K,root = 0;
double p,r,totalPrice;
void dfs(int x,double px)
{
    visited[x] = true;
    if(totalCount[x])
    {
        totalPrice += totalCount[x] * px;
    }
    for(auto &w : ans[x])
    {
        if(!visited[w])
        {
            dfs(w,px*(1 + r*0.01));
        }
    }
}
int main()
{
    memset(pre,-1,sizeof(pre));
   cin>>N>>p>>r;
   ans.resize(N);
   visited.resize(N);
   fill(visited.begin(),visited.end(),false);
   for(int i = 0;i < N;++i)
   {
       cin>>K;
       if(K == 0)
       {
           cin>>totalCount[i];
       }
       else 
       {
           for(int j = 0;j < K;++j)
            {
                int x;
                cin>>x;
                ans[i].push_back(x);
                pre[x] = i;
            }
       }
   }
   
    while(pre[root] != -1)
        ++root;
    dfs(root,p);
    printf("%.1f\n",totalPrice);
    return 0;
}

```

### **1078** **Hashing** 

> 考点：素数（注意：1不是素数也不是合数）、hash函数平方探测
>
> 总结：

```ruby
#include<iostream>
#include<cmath>
#include<cstring>
#include<vector>
#include<algorithm>


using namespace std;

const int max_n = 100005;

int HashTable[max_n] = {0};
int N,M,T;
bool isPrime(int t)
{
    if(t == 1)
        return false;
    for(int i = 2;i <= sqrt(t);++i)
    {
        if(t % i == 0)
            return false;
    }
    return true;
}
void inserTable(int key)
{
    for(int i = 0;i < T;++i)
    {
        int index = (key + i * i)%T;
        if(HashTable[index] == 0)
        {
            HashTable[index] = key;
            cout<<(index % T);
            return ;
        }
    }
    cout<<"-";
}

int main()
{
    cin>>M>>N;
    T = M;
    while(!isPrime(T))
        ++T;

    for(int i = 0;i < N;++i)
    {
        int x;
        cin>>x;
        inserTable(x);
        cout<<(i != N - 1 ? " " : "\n");
    }

    return 0;
}
```

### **1077** **Kuchiguse**

> 考点：字符串
>
> 总结：将每个测试字符串反转，问题就转换为查看是否存在最长前缀字符串了。

```ruby
#include<iostream>
#include<cmath>
#include<cstring>
#include<vector>
#include<algorithm>


using namespace std;

const int max_n = 100005;
int N;
vector<string> ans;
int main()
{
    cin>>N;
    getchar();
    string str;
    int min_le = 1<<30;
    for(int i = 0;i < N;++i)
    {
        getline(cin,str);
        reverse(str.begin(),str.end());
        ans.push_back(str);
        if(min_le > str.size())
        {
            min_le = str.size();
        }
    }

    int cnt = 0;
    char tc;
    string res = "";
    while(cnt < min_le)
    {
        tc = ans[0][cnt];
        int tnum = 1;
        for(int i = 1;i < N;++i)
        {
            if(tc != ans[i][cnt])
            {
                break;
            }
            else 
            {
                ++tnum;
            }
        }
        if(tnum == N)
            res += tc;
        else 
            break;
        ++cnt;
    }
    if(res == "")
        cout<<"nai";
    else 
    {
        reverse(res.begin(),res.end());
        cout<<res<<endl;
    }
    return 0;
}
```

### **1075** **PAT Judge**

> 考点：排序，内存
>
> 总结：注意申请空间的大小，将输出数据尽量的存储起来。结构体中可以先定义`vector`数组再定义范围。

```c
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
struct node
{
    int rank,id,total = 0;
    vector<int> score;
    int passnum = 0;
    bool isshown = false;
};
bool cmp1(node a,node b)
{
    if(a.total != b.total)
        return a.total > b.total;
    else if(a.passnum != b.passnum)
        return a.passnum > b.passnum;
    else 
        return a.id < b.id;
}
int main()
{
    int n,k,m,id,num,score;
    scanf("%d %d %d",&n,&k,&m);
    vector<node> v(n+1);
    for(int i = 1;i <= n;++i)
    {
        v[i].score.resize(k+1,-1);
    }
    vector<int> full(k + 1);
    for(int i = 1;i <= k;++i)
    scanf("%d",&full[i]);
    for(int i = 0;i < m;++i)
    {
        scanf("%d %d %d",&id,&num,&score);
        v[id].id = id;
        v[id].score[num] = max(v[id].score[num],score);
        if(score != -1)
            v[id].isshown = true;
        else if(v[id].score[num] == -1)
            v[id].score[num] = -2;
    }
    for(int i = 1;i <= n;++i)
    {
        for(int j = 1;j <= k;++j)
        {
            if(v[i].score[j] != -1 && v[i].score[j] != -2)
            {
                v[i].total += v[i].score[j];
            }
            if(v[i].score[j] == full[j])
                v[i].passnum++;
        }
    }
    sort(v.begin() + 1,v.end(),cmp1);
    for(int i = 1;i <= n;++i)
    {
        v[i].rank = i;
        if(i != 1 && v[i].total == v[i - 1].total)
            v[i].rank = v[i - 1].rank;
    }
    for(int i = 1;i <= n;++i)
    {
        if(v[i].isshown == true)
        {
            printf("%d %05d %d",v[i].rank,v[i].id,v[i].total);
            for(int j = 1;j <= k;++j)
            {
                if(v[i].score[j] != -1 && v[i].score[j] != -2)
                {
                    printf(" %d",v[i].score[j]);
                }
                else if(v[i].score[j] == -1)
                {
                    printf(" -");
                }
                else if(v[i].score[j] == -2)
                {
                    printf(" 0");
                }
            }
            printf("\n");
        }
    }
    return 0;
}
```

### **1074** **Reversing Linked List**

> 考点：链表
>
> 总结：计数公式`result[i] = list[i/k * k + k - 1 - i%k];`算出当前位于哪一组数据，之后就是从这组数据的末尾，应该输出当前倒数第几个`k - i %k - 1`特别注意取余操作。另外发现`C++`的不同版本编辑器在提交的时候结果不一样，这里用了`C++(clang ++ 6.0.1)`版本，其他版本不通过。

```ruby
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int result[100005];
int ntr[100005];
int data[100005];
int list[100005];
int htr,n,k,temp;
int main()
{
    cin>>htr>>n>>k;
    

    for(int i = 0;i < n;++i)
    {
        cin>>temp>>data[temp]>>ntr[temp];
    }


    int sum = 0;
    while(htr != -1)
    {
        list[sum++] = htr;
        htr = ntr[htr];
    }

    for(int i = 0;i < sum;++i)
        result[i] = list[i];

    for(int i = 0;i < (sum - sum % k);++i)
        result[i] = list[i/k * k + k - 1 - i%k];
    for(int i = 0;i < sum - 1;++i)
    {
        printf("%05d %d %05d\n",result[i],data[result[i]],result[i + 1]);
    }
    printf("%05d %d -1",result[sum - 1],data[result[sum - 1]]);

   
    return 0;
}
```

### **1073** **Scientific Notation**

> 考点：字符串
>
> 总结：注意整数部分正好有一个数字。` the integer portion has exactly one digit`

```ruby
#include <iostream>
#include<string>
#include<cstring>
#include<cmath>

using namespace std;
int main() {
    string str;
    getline(cin,str);
    int i = 0;
    while(str[i++] != 'E');
    string t = str.substr(1,i - 2);
    int n = stoi(str.substr(i));
    if(str[0] == '-')
        printf("-");
    if(n < 0)
    {
        printf("0.");
        for(i = 0;i < abs(n) - 1;++i)
            printf("0");
        for(int j = 0;j < t.size();++j)
        {
            if(t[j] != '.')
                printf("%c",t[j]);
        }
    }
    else 
    {
        printf("%c",t[0]);
        int j,cnt;
        for(j = 2,cnt = 0;j < t.size() && cnt++ < n;++j)
        {
            printf("%c",t[j]);
        }
        if(j == t.size())
        {
            for(int i = 0;i < n - cnt;++i)
                printf("0");//-12000000000
        }
        else 
        {
            printf(".");
            for(;j < t.size();++j)
                printf("%c",t[j]);
        }

    }
    return 0;
}
```

### **1071** **Speech Patterns** 

> 考点：字符串
>
> 总结：字符数字组成的单词

```ruby
#include <iostream>
#include<string>
#include<cstring>
#include<cmath>
#include<unordered_map>
using namespace std;


int main() {
    
    string str,ct,ans = "";
    unordered_map<string,int> ms;
    getline(cin,str);
    int max_le = 0;
    for(int  i = 0;i < str.size();++i)
    {
        if(!isalnum(str[i]))
            continue;
        int j = i;
        while(j < str.size() && isalnum(str[j]))
        {
            char c = tolower(str[j]);
            str[j] = c;
             ++j;
        }
        ct = str.substr(i,j - i);
        ms[ct]++;
        if(ms[ct] > ms[ans])
        {
            ans = ct;
        }
        i = j - 1;
    }
    printf("%s %d",ans.c_str(),ms[ans]);
    return 0;
}
```

### **1070** **Mooncake**

> 考点：贪心算法
>
> 总结：月饼的数量和价格都要定义为`double`变量。对于初始的信息要按照月饼单价递减的顺序进行排序。

```ruby
#include <iostream>
#include<vector>
#include<algorithm>
using namespace std;

struct node
{
    double num;
    double price;
    bool operator<(const node &e)const
    {
        return price/num > e.price /e.num;
    }
};
vector<node> ans;
int N;
double totaldemand;
int main() {
    
    scanf("%d %lf",&N,&totaldemand);
    ans.resize(N);
    for(int i = 0;i < N;++i)
        scanf("%lf",&ans[i].num);
    for(int i = 0;i < N;++i)
        scanf("%lf",&ans[i].price);
    sort(ans.begin(),ans.end());

    double totalProfit = 0;
    for(int i = 0;i < N;++i)
    {
        if(totaldemand >= ans[i].num)
        {
            totalProfit += ans[i].price;
            totaldemand -= ans[i].num;
        }
        else 
        {
            totalProfit += (ans[i].price/ans[i].num)*totaldemand;
            break;
        }
    }
    printf("%.2f\n",totalProfit);
    return 0;
}
```

### **1069** **The Black Hole of Numbers** 

> 考点：字符串
>
> 总结：`string`的`insert`方法` string& insert (size_t pos,   size_t n, char c);`用来填充前面的零
>
> ```xm
> Insertion point: The new contents are inserted before the character at position pos.
> If this is greater than the object's length, it throws out_of_range.
> Note: The first character is denoted by a value of 0 (not 1).
> ```
>
> 

```ruby
#include <iostream>
#include<vector>
#include<algorithm>
using namespace std;

bool cmp(char &a,char &b)
{
    return a > b;
}
int main()
{
    string s,a,b;
    cin>>s;
    s.insert(0,4 - s.size(),'0');//在s前面补字符0
   
    do{
        a = s,b = s;
        sort(a.begin(),a.end(),cmp);
        sort(b.begin(),b.end());

        int result = stoi(a) - stoi(b);

        printf("%04d - %04d = %04d\n",stoi(a),stoi(b),result);

        s = to_string(result);
        s.insert(0,4 - s.size(),'0');
    } while(s != "6174" &&s != "0000");

    return 0;
}
```

### **1067** **Sort with Swap(0, i)** 

> 考点：排序，数组
>
> 总结：以0位置作为哨兵，用哨兵的数与其他数字进行交换，使得其他数字回到有序的位置（最后有序时所处的位置），则排序完成。

```ruby
#include <iostream>
#include<vector>
#include<algorithm>
using namespace std;

int main()
{
    int t,n,a[100010],cnt = 0;
    cin>>n;
    for(int i = 0;i < n;++i)
    {
        cin>>t;
        a[t] = i;
    }

    for(int i = 1;i < n;++i)
    {
        if(a[i] != i)
        {
            while(a[0] != 0)//首先使得哨兵回到有序位置
            {
                swap(a[0],a[a[0]]);
                ++cnt;
            }

            if(a[i] != i)//再将这个要排序的数设置为哨兵
            {
                swap(a[0],a[i]);
                ++cnt;
            }
        }
    }
    cout<<cnt;
}
```

### **1066** **Root of AVL Tree** 

> 考点：平衡二叉树、旋转、求当前节点的最大深度，平衡二叉树的插入。
>
> 总结：区分插入的左右结点，左右高度差的计算。

```ruby
#include <iostream>
#include<vector>
#include<algorithm>
using namespace std;

struct node
{
    int val;
    struct node *left;
    struct node *right;
};
node *rotateLeft(node *root)
{
    node *t = root->right;
    root->right = t->left;
    t->left = root;

    return t;
}
node *rotateRight(node *root)
{
    node *t = root->left;
    root->left = t->right;
    t->right = root;

    return t;
}
node *rotateRightLeft(node *root)
{
    root->right = rotateRight(root->right);
    return rotateLeft(root);
}
node *rotateLeftRight(node *root)
{
    root->left = rotateLeft(root->left);
    return rotateRight(root);
}
int getTreeHeight(node *root)
{
    if(root == nullptr)
        return 0;
    return max(getTreeHeight(root->left),getTreeHeight(root->right)) + 1;
}
node *insert(node *root,int val)
{
    if(root == nullptr)
    {
        root = new node();
        root->val = val;
        root->left = root->right = nullptr;
    }
    else if(val < root->val)
    {
        root->left = insert(root->left,val);
        if(getTreeHeight(root->left) - getTreeHeight(root->right) == 2)
             root = val < root->left->val ? rotateRight(root) : rotateLeftRight(root);
       
    }
    else
    {
        root->right = insert(root->right,val);
        if(getTreeHeight(root->right) - getTreeHeight(root->left) == 2)
            root = val < root->right->val ? rotateRightLeft(root) : rotateLeft(root);
        
    }

    return root;
}
int main()
{
    int N;
    cin>>N;
    node *root = nullptr;
    for(int i = 0;i < N;++i)
    {
        int val;
        cin>>val;
        root = insert(root,val);
    }
    cout<<root->val<<endl;
}
```

### **1065** **A+B and C (64bit)** 

> 考点：溢出判断
>
> 总结：只有两个数同号的时候相加才有可能发生溢出，异号相加不会产生溢出。溢出要么是最大，要么是最小的。

```ruby
#include <iostream>
#include<vector>
#include<string>
#include<algorithm>
using namespace std;


int N;
int main()
{
    scanf("%d",&N);
    for(int i = 1;i <= N;++i)
    {
        long long a,b,c;
        scanf("%lld %lld %lld",&a,&b,&c);
        long long sum = a + b;
        //a,b异号不可能溢出
        printf("Case #%d: ",i);
        if(a > 0 && b > 0 && sum < 0)
        {
            printf("true\n");
        }
        else if(a < 0 && b < 0 && sum >= 0)
        {
            printf("false\n");
        }
        else if(sum > c)
        {
            printf("true\n");
        }
        else 
        {
            printf("false\n");
        }
    }
}
```

### **1062** **Talent and Virtue**

> 考点：排序
>
> 总结：分类排序（规则相同）

```c++
#include <iostream>
#include<vector>
#include<string>
#include<set>
#include<algorithm>
using namespace std;

struct node
{
    int ID_Number;
    int Virtue_Grade;
    int Talent_Grade;
    bool operator<(const node &e)const
    {
        if(Virtue_Grade + Talent_Grade != e.Virtue_Grade + e.Talent_Grade)
        {
            return Virtue_Grade + Talent_Grade > e.Virtue_Grade + e.Talent_Grade;
        }
        else 
        {
            if(Virtue_Grade != e.Virtue_Grade)
                return Virtue_Grade > e.Virtue_Grade;
            else 
                return ID_Number < e.ID_Number;
        }
    }
};


//L是最低分数线（天子和德行都不低于）         H （两个分数）都不低于这个先是 圣贤
//成绩按照递减的顺序排列
//圣贤
//（但是德行不再H一下  天赋在H一下， 贵族
//都在H一下  德行 不低于  天赋   鱼人
//其余的都在之后

///按照成绩递减排序 按照美德递减排序  按照id递增排序

int main()
{
    vector<vector<node> > ans(4);
    
    int N,L,H;
    cin>>N>>L>>H;

    for(int i = 0;i < N;++i)
    {
        int id,vg,tg;
        cin>>id>>vg>>tg;
        if(vg >= L && tg >= L)
        {
             if(vg >= H && tg >= H)
              {
                    ans[0].push_back({id,vg,tg});
              }
               else if(vg >= H &&(tg < H ))
                 {
                ans[1].push_back({id,vg,tg});
                }
                else if(vg < H && tg < H &&vg >= tg )
                {
                    ans[2].push_back({id,vg,tg});
                  }
                else 
                {
                    ans[3].push_back({id,vg,tg});
             }

        }
       
    }
    int M = 0;
    for(int i = 0;i < 4;++i)
    {
        sort(ans[i].begin(),ans[i].end());
        M += ans[i].size();
    }
    cout<<M<<endl;
    for(int i = 0;i < 4;++i)
    {
        for(auto &e : ans[i])
        {
            cout<<e.ID_Number<<" "<<e.Virtue_Grade<<" "<<e.Talent_Grade<<endl;
        }
    }

}
```

### **1063** **Set Similarity** 

> 考点：计算
>
> 总结：利用数学计算简化程序。题目区分两个集合中不同数值的总个数，相同数值的总个数。

```c++
#include <iostream>
#include<vector>
#include<string>
#include<set>
#include<algorithm>
using namespace std;


int N;
vector<set<int> > list;
int main()
{
    cin>>N;
    list.resize(N + 1);

    for(int i = 1;i <= N;++i)
    {
        int M;
        cin>>M;
        for(int j = 0;j < M;++j)
        {
            int x;
            cin>>x;
            list[i].insert(x);
        }
    }

    int K;
    cin>>K;
    while(K--)
    {
        int a,b;
        cin>>a>>b;
        set<int> t1 = list[a],t2 = list[b];
        int cnt = 0;
        for(auto &e : t1)
        {
            if(t2.count(e))
                ++cnt;
        }
        int nc = cnt,nt = t1.size() + t2.size() - cnt;
        double anser = nc/(nt * 1.0) * 100;
        printf("%.1f%\n",anser);
    }

}
```

### **1060** **Are They Equal** 

> 考点：科学计数法，字符串
>
> 总结：`strcmp(a,b)== 0`比较两个字符串是否相同 `strlen(a)`字符串的长度。科学计数法：注意前导零、找出小数点的位置、找出第一个非零数的位置、注意原数为0的情况（小数的的位置和第一个非零数的位置相等）。还有注意记录输出结果的数组，当位数不够要补零的情况。判断两个数的结果是否相等，用判断这两个数的小数和指数是否相等即可。

```java
#include<iostream>
#include<cstring>

using namespace std;
int main()
{
    int n;
    char a[10010],b[10010],A[10010],B[10010];

    scanf("%d%s%s",&n,a,b);

    int cnta = strlen(a),cntb = strlen(b);
    int p  = 0,q = 0;

    for(int i = 0;i < strlen(a);i++)//找到小数点的位置
    {
        if(a[i] == '.')
        {
            cnta = i;
            break;//
        }
    }
    for(int i = 0;i < strlen(b);++i)
    {
        if(b[i] == '.')
        {
            cntb = i;
            break;
        }
    }

    //找到第一个非零数
    while(a[p]== '.' || a[p] == '0')
        p++;
    while(b[q] == '.' || b[q] == '0')
        q++;
    
    if(cnta >= p)//小数点在右侧
    {
        cnta = cnta - p;
    }
    else 
    {//如果小数点在左侧  结果的小数点需要移动到p下标的左侧
        cnta = cnta - (p - 1);
    }

    if(cntb >= q)
    {
        cntb = cntb - q;
    }
    else 
    {
        cntb = cntb - (q - 1);
    }

    int indexa = 0,indexb = 0;

    if(p == strlen(a))
        cnta = 0;
    if(q == strlen(b))
        cntb = 0;

    while(indexa < n)
    {
        if(p < strlen(a) && a[p] != '.')
            A[indexa++] = a[p];
        else if(p >= strlen(a))
            A[indexa++] = '0';
        p++;
    }
    while(indexb < n)
    {
        if(q < strlen(b) && b[q] != '.')
            B[indexb++] = b[q];
        else if(q >= strlen(b))
            B[indexb++] = '0';
        q++;
    }

    if(strcmp(A,B) == 0 &&cnta == cntb)
    {
        printf("YES 0.%s*10^%d",A,cnta);
    }
    else
    {
        printf("NO 0.%s*10^%d 0.%s*10^%d",A,cnta,B,cntb);
    }
    return 0;
}
```

###**1059** **Prime Factors**

> 考点：素数
>
> 总结：构建素数表的基本操作，找出素数因子，注意因数相同以几次方的形式输出。特殊情况值为1的时候。

```java
1059 Prime Factors
#include<iostream>
#include<vector>
#include<cmath>
#include<cstring>

using namespace std;
int main()
{
    vector<int> isPrime(500000,1);


    for(int i = 2;i * i< 500000; ++i)
        for(int j = 2;j * i < 500000;++j)
            isPrime[i * j] = 0;
    long long a ;
    scanf("%lld",&a);
    printf("%lld=",a);
    if(a == 1)
    {
        printf("1");
        return 0;
    }
    bool state = false,flag = false;
    for(int i = 2;i < 500000 && a >= 2;i++)
    {
        int cnt = 0;
        if(a % i == 0)
        {
            while(a&&(a % i == 0))
            {
                a /= i;
                ++cnt;
            }
            flag = true;
        }
        if(flag)
        {
            if(state)printf("*");
            printf("%d",i);
            flag = false;
            state = true;
        }
        if(cnt >= 2)
            printf("^%d",cnt);

    }

    return 0;
}
```

### **1056** **Mice and Rice** 

> 考点：队列
>
> 总结：排名是当前组数加一，每组中的最重的进入下一轮（注意怎么判断每组的最大重量），输出结果是根据初始给出老鼠重量的顺序输出的。

```java
#include<iostream>
#include<queue>
#include<vector>
#include<algorithm>

using namespace std;

struct node
{
    int weight;
    int id;
    int rank_id;
    bool operator<(const node &e)const
    {
        return id < e.id;
    }
};

int n,g;
int main()
{
    scanf("%d %d",&n,&g);
    vector<node> W(n);

    for(int i = 0;i < n;++i)//重量
        cin>>W[i].weight;

    queue<node> pq;
    for(int i = 0;i < n;++i)
    {
        int id;//这个人的重量
        cin>>id;
        W[id].id = id;
        pq.push({W[id].weight,id,0});
    }
    
    int max_weight = -1,max_w_id;
 
    while(!pq.empty())
    {
        int sizen = pq.size();

        if(sizen == 1)
        {
            auto fe = pq.front();
            W[fe.id].rank_id = 1;
            break;
        }

        int groupn = sizen / g;
        if(sizen % g != 0)
            groupn++;
        
         int cnt = 0;
        
        for(int i = 0;i < sizen;++i)
        {
            auto e = pq.front();
            W[e.id].rank_id = groupn + 1;
            pq.pop();
             
            if(max_weight < e.weight)
            {
                max_weight = e.weight;
                max_w_id = e.id;
            }
            ++cnt;
            if(cnt == g || i == sizen - 1)
            {
                pq.push(W[max_w_id]);
                max_weight = 0;
                cnt = 0;
            }
        }
    }

    sort(W.begin(),W.end());

    for(int i = 0;i < n;++i)
    {
        cout<<W[i].rank_id<<(i != n-1 ? " " : "\n");
    }
    return 0;
}
```

### **1055** **The World's Richest**

> 考点：排序
>
> 总结：注意输出范围

```java
#include<iostream>
#include<queue>
#include<string>
#include<vector>
#include<algorithm>

using namespace std;
struct node
{
    string id;
    int age;
    int worth;
    bool operator<(const node &e)const
    {
        if(worth != e.worth)
        {
            return worth > e.worth;
        }
        else 
        {
            if(age != e.age)
            {
                return age < e.age;
            }
            else 
            {
                return id < e.id;
            }
        }
    }
};
vector<node> ans;
int N,K;
int main()
{
    scanf("%d %d",&N,&K);
    for(int i = 0;i < N;++i)
    {
        string nid;
        int ag,wt;
        cin>>nid>>ag>>wt;
        ans.push_back({nid,ag,wt});
    }
    sort(ans.begin(),ans.end());
    for(int i = 0;i < K;++i)
    {
        int max_n,a,b;
        scanf("%d %d %d",&max_n,&a,&b);;
        int cnt = 0;
        printf("Case #%d:\n",(i + 1));
        for(auto &w :  ans)
        {
            if(cnt >= max_n)
                break;
            if(w.age >= a && w.age <= b)
            {
                cout<<w.id<<" "<<w.age<<" "<<w.worth<<endl;
                ++cnt;
            }
        }
        if(cnt == 0)
        {
            cout<<"None\n";
        }
    }
    return 0;
}
```

### **1052** **Linked List Sorting**

> 考点：链表、排序
>
> 总结：注意结点可能不在链表中（大坑）。

```java
#include<iostream>
#include<queue>
#include<string>
#include<vector>
#include<algorithm>

using namespace std;

struct node
{
    int address;
    int data;
    int next;
    bool operator<(const  node &e)const
    {
        return data < e.data;
    }
};
vector<node> ans;
int N,htr;
int ntr[100000],dt[100000];
int main()
{
    scanf("%d %d",&N,&htr);
    for(int i = 0;i < N;++i)
    {
        int a,b,c;
        scanf("%d %d %d",&a,&b,&c);

        ntr[a] = c;
        dt[a] = b;
    }

    int cnt = 0;
    while(htr != -1)
    {
        ++cnt;
        ans.push_back({htr,dt[htr],ntr[htr]});
        htr = ntr[htr];
    }

    if(cnt == 0)
    {
        printf("0 -1\n");
        return 0;
    }
    sort(ans.begin(),ans.end());
    
    printf("%d %05d\n",cnt,ans[0].address);
    
    printf("%05d %d ",ans[0].address,ans[0].data);
    
    if(cnt == 1)
        printf("-1\n");
    else 
    {
        printf("%05d\n",ans[1].address);
        for(int i = 1;i < ans.size();++i)
        {
            printf("%05d %d ",ans[i].address,ans[i].data);
            if(i != ans.size() - 1)
                printf("%05d\n",ans[i+1].address);
            else 
                printf("-1\n");
        }
    
    }

    return 0;
}
```

### **1051** **Pop Sequence**

> 考点：栈的顺序
>
> 总结：将给定的序列每次入栈，入栈过程中观察当前栈顶是否为当前出栈元素。依次遍历入栈序列。遍历结束还有确定出栈序列是否全部输出。

```java
#include<iostream>
#include<queue>
#include<string>
#include<vector>
#include<stack>
#include<algorithm>

using namespace std;
int M,N,K;

bool solve(vector<int>& t)
{
    int curindex = 0;
    stack<int> st;
    for(int i = 1;i <= N;++i)
    {
        st.push(i);
        if(st.size() > M)
            return false;
        
        while (!st.empty() && st.top() == t[curindex])
        {
            st.pop();
            curindex++;
        }
    }

    return curindex == N;
}
int main()
{
    cin>>M>>N>>K;
    while(K--)
    {
        vector<int> t(N);
        for(int i = 0;i < N;++i)
            cin>>t[i];

        cout<<(solve(t) ? "YES\n" : "NO\n");
    }
    return 0;
}
```

### **1048** **Find Coins** 

> 考点：解题思路
>
> 总结：记录某个数是否存在即可。

```java
#include<iostream>
#include<queue>
#include<string>
#include<vector>
#include<stack>
#include<algorithm>

using namespace std;

int a[100005];
int N,M;
int main()
{
    scanf("%d %d",&N,&M);
    for(int i = 0;i < N;++i)
    {
        int x;
        scanf("%d",&x);
        a[x]++;
    }
    bool flag = false;

    for(int i = M;i >= 0;--i)
    {
        if(a[i])
        {
            a[i]--;
            if(a[M-i])
            {
                flag = true;
                printf("%d %d",M - i ,i);
                return 0;
            }
            a[i]++;
        }
    }
    if(!flag)
        printf("No Solution\n");
    return 0;
}
```

###**1047** **Student List for Course**

> 考点：排序
>
> 总结：超时问题！尽量用`scanf()、printf()、`存储字符串可以用`char [],char [][]`、集合尽量用数组。

```java
#include<iostream>
#include<queue>
#include<string>
#include<vector>
#include<stack>
#include<set>
#include<cstring>
#include<algorithm>
#include<unordered_map>

using namespace std;

char ans[50000][5];
int N,K,C;
vector<vector<int> > courses(10005);
bool cmp(int e1,int e2)
{
    return strcmp(ans[e1],ans[e2]) < 0;
}
int main()
{
    scanf("%d %d",&N,&K);
    for(int  i = 0;i < N;++i)
    {
        scanf("%s %d",ans[i],&C);
        for(int j = 0;j < C;++j)
        {
            int cid;
            scanf("%d",&cid);
            courses[cid].push_back(i);
        }
    }
    for(int i = 1;i <= K;++i)
    {
        printf("%d %d\n",i,courses[i].size());
        sort(courses[i].begin(),courses[i].end(),cmp);
       for(int j = 0;j < courses[i].size();++j)
       {
           printf("%s\n",ans[courses[i][j]]);
       }

    }
    return 0;
}
```

### **1044** **Shopping in Mars** 

> 考点：二分查找
>
> 总结：二分查找当前下标开始的大于等于给定m最小值。遍历整个长度和，从下标1开始，更新最接近m的最小值即可，注意二分过程。

```java
#include<iostream>
#include<vector>

using namespace std;

vector<int> sum,resultArr;
int n,m;

void solve(int i,int &j,int &tempsum)
{
    int left = i,right = n;
    while(left < right)
    {
        int mid = (left + right)/2;
        if(sum[mid] - sum[i-1] >= m)
            right = mid;
        else 
            left = mid + 1;
    }
    j = right;
    tempsum = sum[j] - sum[i-1];
}
int main()
{
    scanf("%d%d",&n,&m);
    sum.resize(n+1);
    for(int i = 1;i <= n;++i)
    {
        scanf("%d",&sum[i]);
        sum[i] += sum[i-1];
    }
    int minans = sum[n],j,tempsum;
    for(int i = 1;i <= n;++i)
    {
        solve(i,j,tempsum);
        if(tempsum > minans)
        {
            // cout<<"=========="<<tempsum<<endl;
            continue;
        }
        if(tempsum >= m)
        {
            if(tempsum < minans)
            {
                minans = tempsum;
                resultArr.clear();
            }
            resultArr.push_back(i);
            resultArr.push_back(j);
        }
    }
    for(int i = 0;i < resultArr.size();i += 2)
    {
        printf("%d-%d\n",resultArr[i],resultArr[i + 1]);
    }
    return 0;
}
```

### **1043** **Is It a Binary Search Tree**

> 考点：二叉树的遍历操作，镜像
>
> 总结：注意查找左右子树区间的过程中，注意下标不要写错。题目是给定一个序列判断是否为原或者镜像后的前序序列，是则打印后续序列。

```java
#include<iostream>
#include<vector>

using namespace std;

int n,cnt = 0;
vector<int> ans,postorder(10005);
bool flag;
void solve(int root,int st,int ed)
{
    if(st > ed)
        return;

    int i = st + 1,j = ed;
    int pivot = ans[root];
    if(!flag)
    {
        while(i <= j && ans[i] < pivot)
            ++i;
        while(j >= i && ans[j] >= pivot)
            --j;
    }
    else 
    {
        while(i <= j && ans[i] >= pivot)
            ++i;
        while(j >= i && ans[j] < pivot)
            --j;
    }
    if(i != j + 1)
        return;
    solve(st + 1,st+1,j);
    solve(i,i,ed);
    postorder[cnt++] = pivot;
}
int main()
{
    cin>>n;
    ans.resize(n);
    for(int i = 0;i < n;++i)
    {
        cin>>ans[i];
    }
    flag = false;
    cnt = 0;
    solve(0,0,n-1);
    if(cnt != n ) 
    {
        flag = true;
        cnt = 0;
        solve(0,0,n-1);
    }

    if(cnt  == n )
    {
        printf("YES\n");
        for(int i = 0;i < n;++i)
        {
        cout<<postorder[i]<<(i != n- 1 ? " " : "\n");
        }
    }
    else 
    {
        printf("NO\n");
    }
    


    return 0;
}
```

### **1040** **Longest Symmetric String**

> 考点：字符串
>
> 总结：分两种情况讨论，一种是奇数对称，一种是偶数对称。如果是奇数枚举中间字符位置，然后向两侧检查。如果是偶数，枚举右半侧字符位置或者左半侧字符位置（这里我是模拟右半侧位置）然后向两侧检查相等情况。

```ruby
#include<iostream>
#include<string>

using namespace std;



int main()
{
   string str;
   getline(cin,str);
   int max_len = 0;
   for(int i = 0;i < str.size();++i)
   {
      int pivot = i;
      int ans = 1,j = i + ans;
      while((pivot + ans < str.size())&&(pivot - ans >= 0) && (str[pivot + ans] == str[pivot - ans]))
      {
          ++ans;
      }
      --ans;
      max_len = max(2*ans + 1,max_len);

      ans = 1;
      while((i - ans >= 0)&&(i + (ans - 1) < str.size()) && (str[i - ans] == str[i+(ans - 1)]))
      {
          ans++;
      }
      --ans;
      max_len = max(2*ans,max_len);
   }
    printf("%d",max_len);
    return 0;
}
```

### **1039** **Course List for Student** 

> 考点：排序
>
> 总结：将名字转换为数字存储，利用c语言的输入输出，防止超时

```ruby
#include<iostream>
#include<string>
#include<set>
#include<vector>
#include<unordered_map>
#include<algorithm>
using namespace std;


//姓名 课程总数 递增打印课程索引 (必须按照输入相同的顺序打印)
int getid(char *name)
{
    int id = 0;
    for(int i = 0;i < 3;++i)
        id = 26 * id + (name[i] - 'A');
    id = id * 10 + (name[3] - '0');
    return id;
}
const int maxn = 26 * 26 * 26 * 10 + 10;
vector<int> v[maxn];
int main()
{
    int n,k,no,num,id = 0;
    char name[5];
    scanf("%d %d",&n,&k);
    for(int i = 0;i < k;++i)
    {
        scanf("%d %d",&no,&num);
        for(int  j = 0;j < num;++j)
        {
            scanf("%s",name);
            id = getid(name);
            v[id].push_back(no);
        }
    }
    for(int i = 0;i < n;++i)
    {
        scanf("%s",name);
        id = getid(name);
        sort(v[id].begin(),v[id].end());
        printf("%s %lu",name,v[id].size());
        for(int j = 0;j < v[id].size();++j)
            printf(" %d",v[id][j]);
        printf("\n");
    }
    return 0;
}
```

### **1037** **Magic Coupon**

> 考点：贪心算法
>
> 总结：题目求乘积之和最大值，将两个数组排序，同号的相乘即可。

```ruby
#include<iostream>
#include<string>
#include<set>
#include<vector>
#include<unordered_map>
#include<algorithm>
using namespace std;


int coupons[100005],pro[100005];
int N,C;
int main()
{
    scanf("%d",&N);
    for(int i = 1;i <= N;++i)
        scanf("%d",&coupons[i]);
    scanf("%d",&C);
    for(int i = 1;i <= C;++i)
        scanf("%d",&pro[i]);
    sort(coupons + 1,coupons + N + 1);
    sort(pro + 1,pro + C + 1);

    int sum = 0;
    
    int i = 1,j = 1;
    while(i <= N && j <= C && (coupons[i] < 0 && pro[j] < 0))
    {
        sum += (coupons[i] * pro[j]);
        ++i,++j;
    }
    i = N,j = C;
    while(i >= 1 && j >= 1 &&(coupons[i] >0 && pro[j] > 0))
    {
        sum += (coupons[i] * pro[j]);
        --i,--j;
    }
    printf("%d\n",sum);
    return 0;
}
```

### **1155** **Heap Paths**

> 考点：堆
>
> 总结：右子树路径必须在左子树路径前面，则打印给定二叉树的镜像即可。最后判断父结点比子结点大就不是小根堆，父结点比子结点小就不是大根堆。注意输出路径的时候要特别注意只有左节点没有右节点的情况。

```ruby
#include<iostream>
#include<vector>

using namespace std;
vector<int> hp,pre;
int N,isMin = 1,isMax = 1;

void dfs(int index)
{
    if(index * 2 > N && index * 2 + 1 > N)
    {
        if(index <= N)
        for(int i = 0;i < pre.size();++i)
        {
            cout<<pre[i]<<(i != pre.size() - 1 ? " " : "\n");
        }
    }
    else 
    {
        pre.push_back(hp[2*index + 1]);
        dfs(2*index + 1);
        pre.pop_back();
        pre.push_back(hp[2*index]);
        dfs(2*index);
        pre.pop_back();
    }
}

int main()
{
    cin>>N;
    hp.resize(N+1);

    for(int i = 1;i <= N;++i)    
        cin>>hp[i];
    pre.push_back(hp[1]);
    dfs(1);
    for(int i = 2;i <= N;++i)
    {
        if(hp[i/2] > hp[i])isMin = 0;
        if(hp[i/2] < hp[i])isMax = 0;
    }
    
    if(isMax)
    {
        cout<<"Max Heap\n";
    }
    else 
    {
        cout<<(isMin ? "Min Heap\n" : "Not Heap\n");
    }
    return 0;
}
```

### **1151** **LCA in a Binary Tree**

> 考点：二叉树遍历
>
> 总结：记录中序序列过程中数值对应的位置，若a和b在当前子树的根结点的两边那么当前子树的根结点就是a和b的最近的公共祖先。若在右子树则去右子树查找，若在左子树则在左子树中查找。（题意：给出中序序列和前序序列，再给出两个点，求这两个点的最近公共祖先。）

```ruby
#include<iostream>
#include<vector>
#include<map>

using namespace std;

vector<int> inorder,preoder;
map<int,int> pos;

int M,N;
void LCA(int inl,int inr,int preRoot,int a,int b)
{
 
    if(inl > inr)
        return;

    int inRoot = pos[preoder[preRoot]],ina = pos[a],inb = pos[b];
    if(ina < inRoot && inb < inRoot)
    {
        LCA(inl,inRoot-1,preRoot + 1,a,b);
    }else if((ina < inRoot && inb > inRoot)||(ina > inRoot && inb < inRoot))
    {
        printf("LCA of %d and %d is %d.\n",a,b,inorder[inRoot]);
    }
    else if(ina > inRoot && inb > inRoot)
    {
        LCA(inRoot + 1,inr ,preRoot + 1 + (inRoot - inl),a,b);
    }else if(ina == inRoot)
    {
        printf("%d is an ancestor of %d.\n",a,b);
    }
    else if(inb == inRoot)
    {
        printf("%d is an ancestor of %d.\n",b,a);
    }
}
int main()
{
    cin>>M>>N;
    inorder.resize(N+1);
    preoder.resize(N+1);
    for(int i = 1;i <= N;++i)
    {
        scanf("%d",&inorder[i]);
        pos[inorder[i]] = i;
    }
    for(int i = 1;i <= N;++i)
    {
        scanf("%d",&preoder[i]);
    }
    for(int i = 0;i < M;++i)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        if(pos[a] == 0 && pos[b] == 0)
        {
            printf("ERROR: %d and %d are not found.\n",a,b);
        }
        else if(pos[a] == 0 && pos[b] != 0)
        {
            printf("ERROR: %d is not found.\n",a);
        }
        else if(pos[a] != 0 && pos[b] == 0)
        {
            printf("ERROR: %d is not found.\n",b);
        }
        else 
        {
            LCA(1,N,1,a,b);
        }
    }
    return 0;
}
```

### **1147** **Heaps**

> 考点：堆
>
> 总结：注意层次遍历过程中的下标起始位置。

```ruby
#include<iostream>
#include<vector>
#include<map>

using namespace std;

vector<int> preorder(1005);
int M,N;
void solve(int index,vector<int>& postorder)
{
        if(index >= N)
            return;
        solve(2*index + 1,postorder);
        solve(2*index + 2,postorder);
        postorder.push_back(preorder[index]);
    
}
int main()
{
    cin>>M>>N;
    for(int i = 0;i < M;++i)
    {
        for(int j = 0;j < N;++j)
            cin>>preorder[j];
        int isMin_heap = 1,isMax_heap = 1;

        for(int j = 1;j < N;++j)
        {
            // if(preorder[j/2] > preorder[j])
            //     isMin_heap = 0;
            // if(preorder[j/2] < preorder[j])
            //     isMax_heap = 0;
            if(preorder[j] > preorder[(j-1)/2])
                isMax_heap = 0;
            if(preorder[j] < preorder[(j-1)/2])
                isMin_heap = 0;
        }
        if(isMax_heap == 1)
        {
            printf("Max Heap\n");
        }
        else  
        {
            cout<<(isMin_heap == 1 ? "Min Heap\n" : "Not Heap\n");
        }
        vector<int> postorder;
        solve(0,postorder);
        for(int j = 0;j < postorder.size();++j)
            cout<<postorder[j]<<(j != postorder.size() - 1 ? " " : "\n");
    }
    return 0;
}
```

### **1143** **Lowest Common Ancestor** 

> 考点：
>
> 总结：给出二叉搜索树的前序遍历找出，两个数的最低公共祖先。根据二叉搜索树的性质，可以很清楚的判断出两个数的祖先。

```ruby
#include<iostream>
#include<vector>
#include<map>

using namespace std;
int M,N;
vector<int> preorder;
map<int,int> ms;

int main()
{
    cin>>M>>N;
    preorder.resize(N+1);

    for(int i = 1;i <= N;++i)
    {
        cin>>preorder[i];
        ms[preorder[i]] = i;
    }
    for(int i = 0;i < M;++i)
    {
        int a,b;
        cin>>a>>b;
        if(ms[a] == 0 && ms[b] == 0)
        {
           cout<<"ERROR: "<<a<<" and "<<b<<" are not found.\n"; 
        }
        else if(ms[a] == 0 && ms[b] != 0)
        {
            cout<<"ERROR: "<<a<<" is not found.\n";
        }
        else if(ms[a] != 0 && ms[b] == 0)
        {
            cout<<"ERROR: "<<b<<" is not found.\n";
        }
        else 
        {
            int t;
           for(int j = 1;j <= N;++j)
           {
                t = preorder[j];
               if((t > a && t <= b) || ( t <= a && t > b) || t == a || t == b)  
                    break;
           }

           if(t == a || t == b)
           {
               printf("%d is an ancestor of %d.\n",t,(t == a ? b : a));
           }
           else 
           {
               printf("LCA of %d and %d is %d.\n",a,b,t);
           }
        }
    }

    return 0;
}
```

### **1139** **First Contact**

> 考点：邻接表，输出格式
>
> 总结：输出两个人的朋友中互为朋友的情况，需要排序，利用map集合减少程序耗时(数学计算代替二维数组)。

```ruby
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include<unordered_map>
#include<cmath>
#include<cstring>

using namespace std;

const int max_n = 10005;

bool cmp(pair<int,int> &e1,pair<int,int> &e2)
{
	if(e1.first != e2.first)
	{
		return e1.first < e2.first;
	}
	else 
	{
		return e1.second < e2.second;
	}
}
int N,M;
unordered_map<int,bool> connects;
vector<vector<int> > v(max_n);

int main()
{
	cin>>N>>M;
    
	for(int i = 0;i < M;++i)
	{
		string a,b;
		cin>>a>>b;

		if(a.length() == b.length())
		{
			v[abs(stoi(a))].push_back(abs(stoi(b)));
			v[abs(stoi(b))].push_back(abs(stoi(a)));
		}
		connects[abs(stoi(a)) * 10000 + abs(stoi(b))] = connects[abs(stoi(b)) * 10000 + abs(stoi(a))] = true;
	}
	int k;
	cin>>k;
	for(int i = 0;i < k;++i)
	{
		string x,y;
		cin>>x>>y;

		vector<pair<int,int> > ans;

		for(int j = 0;j < v[abs(stoi(x))].size();j++)
		{
			for(int d = 0;d < v[abs(stoi(y))].size();d++)
			{
				if(v[abs(stoi(x))][j] == abs(stoi(y)) || v[abs(stoi(y))][d] == abs(stoi(x)))
					continue;
				
				int r1,r2;
				r1 = v[abs(stoi(x))][j];
				r2  = v[abs(stoi(y))][d];
				if(connects[r1 * 10000 + r2] == true)
					ans.push_back({r1,r2});
			}
		}

		cout<<ans.size()<<endl;
		sort(ans.begin(),ans.end(),cmp);
		for(auto &w : ans)
		{
			printf("%04d %04d\n",w.first,w.second);
		}
	}


	return 0;
}
```

### **1138** **Postorder Traversal**

> 考点：二叉树的遍历
>
> 总结：

```ruby
#include<iostream>
#include<vector>

using namespace std;

vector<int> pre_order,in_order,post_order;
int N;
void solve(int root,int  st,int ed)
{
	if(st > ed)
		return;
	int  x = pre_order[root];

	int  i = st,j = ed;
	while(in_order[i] != x && i <= ed)
		++i;
	

	solve(root + 1,st,i - 1);
	solve(root + (i - st) + 1,i + 1,ed);

	post_order.push_back(x);
}
int main()
{
	cin>>N;
	pre_order.resize(N+1);
	in_order.resize(N+1);
	for(int i = 1;i <= N;++i)
		cin>>pre_order[i];

	for(int i = 1;i <= N;++i)
		cin>>in_order[i];
	solve(1,1,N);
	cout<<post_order[0]<<endl;
	return 0;
}
```



```ruby

bool flag = false;
void postOrder(int prel, int inl, int inr) {
    if (inl > inr || flag == true) return;
    int i = inl;
    while (in[i] != pre[prel]) i++;
    postOrder(prel+1, inl, i-1);
    postOrder(prel+i-inl+1, i+1, inr);
    if (flag == false) {
        printf("%d", in[i]);
        flag = true;
    }

```

### **1137** **Final Grading** 

> 考点：排序
>
> 总结：对有资格的人员进行排序，总成绩注意四舍五入取整即可。

```ruby
#include<iostream>
#include<vector>
#include<unordered_map>
#include<algorithm>

using namespace std;

//descending(final) id(ascending) 
struct node
{
	int G_programing = -1;
	int G_midterm = -1;
	int G_final = -1;
	int G_total;
	string id;
	bool operator<(const node &e)const
	{
		if(G_total != e.G_total)
		{
			return G_total > e.G_total;
		}
		else 
		{
			return id < e.id;
		}
	}
};

unordered_map<string,node> list;
vector<node> ans;
int  P,M,N;
int main()
{
	cin>>P>>M>>N;
	for(int i = 0;i < P;++i)
	{
		string id;
		int pr_score;
		cin>>id>>pr_score;
		list[id].G_programing = pr_score;
	}
	for(int i = 0;i < M;++i)
	{
		string id;
		int G_fid;
		cin>>id>>G_fid;
		list[id].G_midterm = G_fid;
	}
	for(int i = 0;i < N;++i)
	{
		string id;
		int f_id;
		cin>>id>>f_id;
		list[id].G_final = f_id;
		int ta;
		if(list[id].G_midterm > list[id].G_final)
		{
			ta = (int)(list[id].G_midterm * 0.4 + list[id].G_final * 0.6 + 0.5);
		}
		else 
		{
			ta = list[id].G_final;
		}
		if(list[id].G_programing >= 200 && ta >= 60)
		ans.push_back({list[id].G_programing,list[id].G_midterm,list[id].G_final,ta,id});
	}
	sort(ans.begin(),ans.end());

	for(auto &w : ans)
	{
		cout<<w.id<<" "<<w.G_programing<<" "<<w.G_midterm<<" "<<w.G_final<<" "<<w.G_total<<endl;
	}
	return 0;
}
```

### **1135** **Is It A Red-Black Tree**

> 考点：红黑树（平衡二叉树）
>
> 总结：注意负号在判断两个结点大小中的影响，计算对应子树中黑色节点的数量。



```ruby
#include<iostream>
#include<cmath>
#include<vector>

using namespace std;

struct node
{
	int val;
	struct node *left;
	struct node *right;
};
int K,N;
node* build(node *root,int val)
{
	if(root == nullptr)
	{
		root = new node();
		root->val = val;
		root->left = root->right = nullptr;
	}
	else if(abs(val) <= abs(root->val))
	{
		root->left = build(root->left,val);
	}
	else 
	{
		root->right = build(root->right,val);
	}
	return root;
}
int getback(node *root)
{
	if(root == nullptr)
		return 0;
	int l = getback(root->left);
	int r = getback(root->right);

	return root->val > 0 ? max(l,r) + 1 : max(l,r);
}
bool judge1(node *root)
{
	if(root == nullptr)
		return true;
	if(root->val < 0)
	{
		if(root->left != nullptr && root->left->val < 0)return false;
		if(root->right != nullptr && root->right->val < 0)return false;
	}
	return judge1(root->left)&&judge1(root->right);
}
bool judge2(node *root)
{
	if(root == nullptr)
		return true;

	int l = getback(root->left);
	int r = getback(root->right);

	if(l != r)
		return false;
	return judge2(root->left)&&judge2(root->right);
}
int main()
{
	cin>>K;
	while(K--)
	{
		cin>>N;
		vector<int> arr(N);

		node *root = nullptr;
		for(int i = 0;i < N;++i)
		{
			cin>>arr[i];
			root = build(root,arr[i]);
		}

		if(arr[0] < 0 || judge2(root) == false || judge1(root) == false)
		{
			printf("No\n");
		}
		else 
		{
			printf("Yes\n");
		}

	}
	return 0;
}
```

### **1131** **Subway Map**

> 考点：图的遍历
>
> 总结：要求打印途径站点最少的路径，如果最少路径不唯一则打印换乘次数最少的路径。
>
> 输出途径站点的数量，路径（要求除了起始站外，只打印换乘站）。

```c++
#include<iostream>
#include<vector>
#include<unordered_map>

using namespace std;
vector<vector<int> > v(10000);
int visit[10000],minCnt,minTransfere,start,end1;
unordered_map<int,int> line;
vector<int> path,tempPath;

int transferCnt(vector<int> a)
{
	int cnt = -1,preLine = 0;
	for(int i = 1;i < a.size();i++)
	{
		if(line[a[i-1] * 10000 + a[i]] != preLine)
			cnt++;
		preLine = line[a[i-1] * 10000 + a[i]];
	}
	return cnt;
}
void dfs(int node,int cnt)
{
	if(node == end1 && (cnt < minCnt || (cnt == minCnt && transferCnt(tempPath) < minTransfere)))
	{
		minCnt = cnt;
		minTransfere = transferCnt(tempPath);
		path = tempPath;
	}

	if(node == end1)
		return;
	for(int i = 0;i < v[node].size();++i)
	{
		if(visit[v[node][i]] == 0)
		{
			visit[v[node][i]] = 1;
			tempPath.push_back(v[node][i]);
			dfs(v[node][i],cnt + 1);
			visit[v[node][i]] = 0;
			tempPath.pop_back();
		}
	}
}
int main()
{
	int n,m,k,pre,temp;
	scanf("%d",&n);
	for(int i = 0;i < n;++i)
	{
		scanf("%d%d",&m,&pre);
		for(int  j = 1;j < m;++j)
		{
			scanf("%d",&temp);
			v[pre].push_back(temp);
			v[temp].push_back(pre);
			line[pre * 10000 + temp] = line[temp * 10000 + pre] = i + 1;
			pre = temp;
		}
	}

	scanf("%d",&k);
	for(int i = 0;i < k;++i)
	{
		scanf("%d%d",&start,&end1);
		minCnt = 99999,minTransfere = 99999;
		tempPath.clear();
		tempPath.push_back(start);
		visit[start] = 1;
		dfs(start,0);
		visit[start] = 0;
		printf("%d\n",minCnt);
		int preLine = 0,preTransfer = start;
		for(int j = 1;j < path.size();j++)
		{
			if(line[path[j-1] * 10000 + path[j]] != preLine)
			{
				if(preLine != 0)
					printf("Take Line#%d from %04d to %04d.\n",preLine,preTransfer,path[j-1]);
				preLine = line[path[j-1] * 10000 + path[j]];
				preTransfer = path[j-1];
			}
		}
		printf("Take Line#%d from %04d to %04d.\n",preLine,preTransfer,end1);
	}
	return 0;
}
```

### **1127** **ZigZagging on a Tree** 

> 考点：二叉树的遍历操作
>
> 总结：层次遍历，只不过不同层次的输出顺序不一样

```c++
#include<iostream>
#include<vector>

using namespace std;
int n,max_level = 0;
vector<int> post_order,in_order;
vector<vector<int> > levels_num(35);
void solve(int in_st,int in_ed,int pos_root,int level)
{
	if(in_st > in_ed)
		return;

	if(max_level < level)
		max_level = level;

	int x = post_order[pos_root];
	int i = in_st,j = in_ed;

	while(in_order[i] != x && i <= j)
		++i;
	levels_num[level].push_back(x);
	solve(in_st,i-1,pos_root - (j - i) - 1,level+1);
	solve(i + 1,in_ed,pos_root - 1,level + 1);
}
int main()
{
	cin>>n;
	post_order.resize(n);
	in_order.resize(n);
	for(int i = 0;i < n;++i)
		cin>>in_order[i];
	for(int i = 0;i < n;++i)
		cin>>post_order[i];

	solve(0,n-1,n-1,1);
	cout<<levels_num[1][0];
	for(int i = 2;i <= max_level;++i)
	{
		if(i % 2 != 0)
		{
			for(int j = levels_num[i].size() - 1;j >= 0;--j)
			{
				cout<<" "<<levels_num[i][j];
			}
		}
		else 
		{
			for(int j = 0;j <= levels_num[i].size() - 1;++j)
			{
				cout<<" "<<levels_num[i][j];
			}
		}
	}
	return 0;
}
```

### **1119** **Pre- and Post-order Traversals** 

> 考点：
>
> 总结：注意计算前序序列起始终点；后续序列起始终点。只有一种情况的判断（因为可能会存在多种情况，这种情况就是一个结点可能是根的左孩子也可能是根的右孩子，如果发现了一个无法确定的状态。有因为题目只需要输出一个方案，可以假定这个不可确定的孩子的状态为右孩子，接下来的问题是如何求根结点和左右孩子划分的问题了）

```c++
#include<iostream>
#include<vector>

using namespace std;

bool isUnque = true;
vector<int> post_order,pre_order;
vector<int> in_order;
void solve(int pre_st,int pre_end,int post_st,int post_ed)
{
	if(pre_st == pre_end)
	{
		in_order.push_back(pre_order[pre_st]);
		return ;
	}


	
	if(post_order[post_ed] == pre_order[pre_st])
	{
		int i = pre_st + 1;
		//找到后续遍历中的后面第二个根结点（也就是除了左右子数中）
		while(i <= pre_end && pre_order[i] != post_order[post_ed - 1])
			++i;

		//查看它在前序遍历的位置
		if(i - pre_st > 1)
		{
			solve(pre_st + 1,i-1 ,post_st, post_st + (i - (pre_st + 1)) - 1);
		
		}
		else
		{
			isUnque = false;
		}
			in_order.push_back(post_order[post_ed]);
			//右子树                    左子树的长度（i - (pre_st + 1)）
			solve(i,pre_end,post_st + (i - (pre_st + 1)),post_ed - 1);
	}
}
int main()
{
	int n;
	cin>>n;
	pre_order.resize(n);
	post_order.resize(n);
	for(int i = 0;i < n;++i)
		cin>>pre_order[i];

	for(int i = 0;i < n;++i)
		cin>>post_order[i];
	
	solve(0,n-1,0,n-1);
	printf("%s\n%d",isUnque == true ? "Yes" : "No",in_order[0]);
	for(int i = 1;i < in_order.size();++i)
		printf(" %d",in_order[i]);
	printf("\n");
	return 0;
}
```

### **1115** **Counting Nodes in a BST**

> 考点：二叉树的遍历
>
> 总结：



```c++
#include<iostream>
#include<vector>
#include<cstring>

using namespace std;

const int N  = 100005;
typedef struct node LinkNode;
int dept_node[N],max_deep  = 0;
struct node
{
	int val;
	LinkNode *left,*right;
};
LinkNode* builtTree(LinkNode *root,int val)
{
	if(root == NULL)
	{
		root = new node();
		root->val = val;
		root->left = root->right = NULL;
	}
	else if(val <= root->val)
	{
		root->left = builtTree(root->left,val);
	}
	else 
	{
		root->right = builtTree(root->right,val);
	}
	return root;
}
void dfs(LinkNode *root,int deep)
{
	if(root == NULL)
		return;

	if(max_deep < deep)
	{
		max_deep = deep;
	}
	dept_node[deep]++;
	dfs(root->left,deep + 1);

	dfs(root->right,deep + 1);
}
int main()
{
	memset(dept_node,0,sizeof(dept_node));

	int n;
	cin>>n;
	LinkNode *root = nullptr;
	for(int i = 0;i < n;++i)
	{
		int a;
		cin>>a;
		root = builtTree(root,a);
	}

	dfs(root,1);
	int n1 = dept_node[max_deep],n2 = dept_node[max_deep-1];
	printf("%d + %d = %d\n",n1,n2,(n1 + n2));
	return 0;
}
```

### **1111** **Online Map** 

> 考点：迪杰斯特拉算法
>
> 总结：执行两次算法，第一种是路径最短，不唯一选择时间最少的；第二种是时间最少，不唯一选择经过结点最少的。

```c++

```

### **1107** **Social Clusters** 

> 考点：并查集
>
> 总结：利用`couserId[t]`表示任意一个喜欢`t`活动的人的编号。如果当前的课程`t`，之前并没有人喜欢过，那么`couserId[t] = i `，`i`为它自己的编号，表示`i`为喜欢`courseId[t]`的一个人的编号。`courserId[t]`是喜欢`t`活动的人的编号，那么`find(courseId[t])`就是喜欢这个活动的人所处的社交圈子的根结点，合并根结点和当前人的编号的结点`i`。即`un(i,find(courseId[t]))`，把它们处在同一个社交圈子里面。

```c++
#include<iostream>
#include<vector>
#include<numeric>
#include<set>
#include<algorithm>

using namespace std;

int N;
vector<int> pre(1005),couserId(1005);
int find(int x)
{
	return pre[x] == x ? x : find(pre[x]);
}
void un(int x,int y)
{
	int nx = find(x), ny = find(y);
	if(nx == ny)
		return;
	if(nx > ny)
		pre[nx] = ny;
	else 
		pre[ny] = nx;
}
bool cmp(int a,int b)
{
	return a > b;
}
int main()
{
	iota(pre.begin(),pre.end(),0);
	cin>>N;
	for(int i = 1;i <= N;++i)
	{
		int num;
		char c;
		cin>>num>>c;
		for(int j = 0;j < num;++j)
		{
			int cid;
			cin>>cid;
			if(couserId[cid] == 0)//记录该活动对应的人
				couserId[cid] = i;
			un(i,couserId[cid]);
		}
	}
	vector<int> rootid(N+1);
	for(int i = 1;i <= N;++i)
	{
		rootid[find(i)]++;
	}
	int cnt = 0;
	for(int i = 1;i <= N;++i)
	{
		if(rootid[i] != 0)
			++cnt;
	}
	cout<<cnt<<endl;
	sort(rootid.begin(),rootid.end(),cmp);
	for(int i = 0;i < cnt;++i)
		cout<<rootid[i]<<(i != cnt - 1 ? " " : "\n");
	return 0;
}
```

### **1103** **Integer Factorization**

> 考点：dfs + 剪枝
>
> 总结：



```c++
#include<iostream>
#include<vector>
#include<cmath>

using namespace std;
int n,k,p,maxFacSum = -1;
vector<int> v,ans,tempAns;
//先把i从0开始所有的i的p次方的值存储在v[i]中，直到v[i]>n为止。然后深度优先搜索，记录当前正在相加的index(即v[i]的i的值)
void init()
{
	int temp = 0,index = 1;
	while(temp <= n)
	{
		v.push_back(temp);
		temp = pow(index,p);
		index++;
	}
}
/*深度优先搜素，记录当前正在相加的index（即v[i]的i的值），当前的总和tempSum，当前K的总个数tempK,
以及因为题目中要求输出因子的和最大的那个，所以保存一个facSum为当前因子的和，让它和maxFacSum比较，如果
比maxFacSum大就更新maxFacSum和要求的ans数组的值

在ans数组里面存储因子的序列，tempAns为当前深度优先遍历而来的序列，从v[i]的最后一个index开始直到index ==1，因为
这样才能保证ans和tempAns数组里面保存的是从大到小的因子的顺序。一开始maxFacSum == -1，如果dfs后maxFacSum并
没有被更新，还是-1，那么就输出impossible，否则输出答案

1tempK == k但是tempSum != n的时候
2在枚举的时候，按顺序枚举，上界或下界可进行剪枝
3当且仅当 tempSum + v[index] <= n时，进行下一层的DFS，而不要进入下一层DFS发现不满足条件再返回，
这样开销会比较大。
*/
void dfs(int index,int tempSum,int tempK,int facSum)
{
	if(tempK == k)
	{
		if(tempSum == n && facSum > maxFacSum)//结果为n并且因子的和最大
		{
			ans = tempAns;
			maxFacSum = facSum;
		}
		return;
	}

	while (index >= 1)
	{
		if(tempSum + v[index] <= n)
		{
			tempAns[tempK] = index;
			dfs(index,tempSum + v[index],tempK + 1,facSum + index);
		}
		if(index == 1)
			return ;
		index--;
	}
}

int main()
{
	scanf("%d%d%d",&n,&k,&p);
	init();
	tempAns.resize(k);
	dfs(v.size()-1,0,0,0);
	if(maxFacSum == -1)
	{
		printf("Impossible");
		return 0;
	}
	printf("%d = ",n);
	for(int i = 0;i < ans.size();i++)
	{
		if(i != 0)
			printf(" + ");
		printf("%d^%d",ans[i],p);
	}
	return 0;
}

```

### **1099** **Build A Binary Search Tree**

> 考点：二叉树的遍历
>
> 总结：层次遍历，递归，二叉搜索树性质

```c++
#include<iostream>
#include<vector>
#include<cmath>
#include<algorithm>

using namespace std;
using pii = pair<int,int>;

vector<pii> t;
vector<int> a;
vector<vector<int> > level_order(105);
int n,cnt = 0,max_level = 0;
void dfs(int x,int level)
{
	if(x == -1)
		return ; 

	max_level = max(max_level,level);

	dfs(t[x].first,level + 1);

	level_order[level].push_back(a[cnt++]);
	dfs(t[x].second,level + 1);
}
int main()
{
	cin>>n;
	t.resize(n);
	for(int i = 0;i < n;++i)
	{
		int l,r;
		cin>>l>>r;
		t[i].first = l;
		t[i].second = r;
	}
	for(int i = 0;i < n;++i)
	{
		int x;
		cin>>x;
		a.push_back(x);
	}
	sort(a.begin(),a.end());
	dfs(0,1);
	for(int i = 1;i <= max_level;++i)
	{
		for(auto &w : level_order[i])
			cout<<w<<(--cnt ? " " : "\n");
	}
	return 0;
}
```

