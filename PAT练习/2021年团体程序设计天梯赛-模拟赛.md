### **L1-1 宇宙无敌大招呼 (5 分)**

>

```c++
//2021年4月19日14:50:12
#include<iostream>
#include<string>
using namespace std;

int main()
{
    string str;
    getline(cin,str);
    cout<<"Hello "<<str<<endl;
    return 0;
}
```

### **L1-2 考试周 (5 分)**

> 数学

```c++
#include<iostream>

using namespace std;
//2021年4月19日14:52:27

int main()
{
    int a,b;
    double x;
    cin>>a>>b;
    x = a/(b*1.0);
    printf("%d/%.1f=%d\n",a,x,b);
    return 0;
}
```

### **L1-3 真的恭喜你 (10 分)**

>循环判断

```c++
#include<iostream>

//2021年4月19日14:55:35
using namespace std;
int main()
{
    int a;
    scanf("%d",&a);
    if(a >= 90)
    {
        printf("gong xi ni kao le %d fen!\n",a);
    }
    else 
    {
        printf("kao le %d fen bie xie qi!\n",a);
    }
    return 0;
}
```

### **L1-4 Cassels方程 (10 分)**

>循环语句

```c++
#include<iostream>
#include<cmath>

//2021年4月19日15:00:16
using namespace std;


int main()
{
    int n,x,y,z;
    scanf("%d",&n);
    for(int i = 0;i < n;i++)
    {
        scanf("%d %d %d",&x,&y,&z);
        if((x * x + y * y + z * z == 3 * x * y * z))
        {
            printf("Yes\n");
        }
        else 
        {
            printf("No\n");
        }
    }
    return 0;
}
```

### **L1-5 6翻了 (15 分)**

>字符串：计数模板

```c++
#include<iostream>
#include<string>

//2021年4月19日15:01:54
using namespace std;

int main()
{
    string str;
    getline(cin,str);

    for(int i = 0;i < str.size();)
    {
        if(str[i] != '6')
        {
            cout<<str[i];
            i++;
        }
        else 
        {
            int j = i;
            while(str[j] == str[i] && j < str.size())
                ++j;
            int len = j - i;
            if(len > 3 && len <= 9)
            {
                printf("9");
            }
            else if(len > 9)
            {
                printf("27");
            }
            else 
            {
                while(len--)
                    printf("6");
            }
            i = j;
        }
    }
    return 0;
}
```

### L1-6 不变初心数 (15 分)

>数学，模拟

```c++
//2021年4月19日15:06:00
#include<iostream>
#include<string>

using namespace std;

int main()
{
    int  n;
    scanf("%d",&n);
    int temp;
    bool flag = true;
    for(int i = 0;i < n;i++)
    {
        scanf("%d",&temp);
        int totial = 0;
        string t = to_string(temp);
        for(int j = 0;j < t.size();j++)
            totial += t[j] - '0';
        flag = true;
        for(int j = 2;j < 10;j++)
        {
            int cur = temp * j;
            string t_cur = to_string(cur);
            int sum = 0;
            for(int k = 0;k < t_cur.size();k++)
            {
                sum += t_cur[k] - '0';
            }
            if(sum != totial)
            {
                flag = false;
                break;
            }
        }
        if(flag)
        {
            printf("%d\n",totial);
        }
        else
        {
            printf("NO\n");
        }
    }
    return 0;
}
```

### **L1-7 整除光棍 (20 分)**

>字符串，除法，大数运算

```c++
//2021年4月19日15:11:46
#include<iostream>
#include<string>

using namespace std;

int main()
{
    int  x;
    scanf("%d",&x);
    string cur = "1";
    string res = "";
    int len = 1;
    while(true)
    {
        res = "";
        int pre = 0;
        for(int i = 0;i < cur.size();i++)
        {
            pre = pre * 10 + cur[i] - '0';
            res.push_back((pre/x + '0'));
            pre = pre % x;
        }
        if(pre == 0)
        {
            break;
        }
        cur.push_back('1');
        len++;
    }

    int i = 0;
    while (i < res.size() && res[i] == '0')
    {
        i++;
    }
    string re_str = res.substr(i);
    cout<<re_str<<" "<<len<<endl;
    
    return 0;
}
```

### **L1-8 编程团体赛 (20 分)**

>

```c++
//2021年4月19日15:18:14
#include<iostream>
#include<unordered_map>
using namespace std;
unordered_map<int,int> list;
int main()
{
    int n;
    scanf("%d",&n);
    int a,b,c,max_sc = 0,max_id;
    for(int i = 0;i < n;i++)
    {
        scanf("%d-%d %d",&a,&b,&c);
        list[a] += c;
        if(max_sc < list[a])
        {
            max_sc = list[a];
            max_id = a;
        }
    }
    printf("%d %d\n",max_id,max_sc);
    return 0;
}
```

### **L2-1 彩虹瓶 (25 分)**

> 堆栈模拟

```c++
//2021年4月19日15:21:19
#include<iostream>
#include<stack>
#include<vector>

using namespace std;

int main()
{
    int n,m,k,temp;
    scanf("%d %d %d",&n,&m,&k);
    for(int i = 0;i < k;i++)
    {
        stack<int> st;
        int cur = 1;
        bool flag = true;
        for(int j = 0;j < n;j++)
        {
            scanf("%d",&temp);
            st.push(temp);
            while(!st.empty() && cur == st.top())
            {
                st.pop();
                cur++;
            }
            if(st.size() > m)
            {
                flag = false;
            }
        }
        if(flag && cur != n + 1)
            flag = false;
        printf("%s\n",(flag ? "YES" : "NO"));
    }

    return 0;
}
```

### **L2-2 三足鼎立 (25 分)**

> 注意数据范围：`long long`
>
> 二分查找：
>
> 不多说，先给出两个函数的定义：
>
> lower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找的。
>
> 函数`lower_bound()`在`first`和`last`中的**前闭后开区间**进行二分查找，返回大于或等于`val`的第一个元素位置。如果所有元素都小于`val`，则返回`last`的位置。
>
> 函数`upper_bound()`在`first`和`last`中的**前闭后开区间**进行二分查找，返回大于`val`的第一个元素位置。如果所有元素都小于`val`，则返回`last`的位置。
>
> 三角形的组成定理：两边之和大于第三边

```c++
//2021年4月19日15:31:43
#include<iostream>
#include<algorithm>
#include<vector>

using namespace std;

int main()
{
    int n,cur;
    scanf("%d %d",&n,&cur);
    vector<int> ans(n);
    for(int i = 0;i < n;i++)
    {
        scanf("%d",&ans[i]);
    }
    sort(ans.begin(),ans.end());
    long long cnt = 0;
    for(int i = 0;i < ans.size();i++)
    {
        // 满足 abs(a-b) <= c 
        int left = upper_bound(ans.begin() + i + 1,ans.end(),abs(ans[i] - cur)) - ans.begin();
        //满足 a + b < c
        int right = lower_bound(ans.begin() + i + 1 ,ans.end(),(ans[i] + cur )) - ans.begin();
        cnt += right - left;

        // int q = lower_bound(ans.begin() + i + 1,ans.end(),cur + ans[i]) - ans.begin();
        // int p = upper_bound(ans.begin() + i + 1,ans.end(),abs(ans[i] - cur)) - ans.begin();
        // cnt += q - p;

    }
    printf("%lld\n",cnt);
    return 0;
}
```

### L2-3 这是二叉搜索树吗？ (25 分)

>二叉树的遍历，dfs;  注意根结点时候的判断

```c++
//2021年4月19日16:05:44
#include<iostream>
#include<vector>

using namespace std;
const int N = 10005;

int preorder[N];
int n;
bool flag = true;
vector<int> inorder;
void solve(int st,int ed)
{
    if(st > ed)
        return;
    
    //sure tree
    if(flag)
    {
        int i = st + 1;
        int root = preorder[st];
       
        //left < root
        while(i <= ed && preorder[i] < root)
            ++i;
        int j = ed;
        //right >= root
        while(j >= st + 1 && preorder[j] >= root)
            --j;
        if(i - j != 1)
            return;
        solve(st + 1,j);
        solve(i,ed);
        inorder.push_back(root);
    }
    else //not sure
    {
        int i = st + 1;
        int root = preorder[st];
        // cout<<root<<" ";
        //left >= root
        while(i <= ed && preorder[i] >= root)
            ++i;
        //right < root
        int j = ed;
        while(j > st && preorder[j] < root)
            --j;
        if(i - j != 1)
            return;
        solve(st + 1,i - 1);
        solve(i,ed);
        inorder.push_back(root);
    }
}
int main()
{
    cin>>n;
    for(int i = 0;i < n;i++)
       scanf("%d",&preorder[i]);
    solve(0,n-1);
    if(inorder.size() != n)
    {
        inorder.clear();
        //reversal  tree
        flag = false;
        solve(0,n-1);
    }
    if(inorder.size() == n)
    {
        printf("YES\n");
        for(int i = 0;i < inorder.size();i++)
        {
            printf("%d",inorder[i]);
            if(i != inorder.size() - 1)
                printf(" ");
            else
                printf("\n");
        }
    }
    else 
    {
        printf("NO\n");
    }
    
    return 0;
}
```

### **L2-4 网红点打卡攻略 (25 分)**

> 邻接矩阵：环路：
>
> 注意：重复访问的结点

```c++
//2021年4月19日16:21:06
#include<iostream>
#include<cstring>
#include<vector>

using namespace std;
const int N = 250;

int g[N][N];

int n,m,k;
int judge()
{
    int np;
    cin>>np;
    vector<int> ans(np+1);
    int hash_table[N] = {0};
    for(int i = 1;i <= np;i++)
    {
        scanf("%d",&ans[i]);
    }
    //searcher repeat point
    for(int i = 1;i <= np;i++)
    {
        if(hash_table[ans[i]] == 0)
            hash_table[ans[i]] = 1;
        else 
            return 0;
    }
    //from home to first and from end to home
    int total = g[0][ans[1]] + g[ans[np]][0];
    //not simple or diconnectd
    if(np != n || total > 0x3f3f3f3f)
        return 0;
    for(int i = 2;i <= np;i++)
    {
        //diconnected
        if(g[ans[i-1]][ans[i]] == 0x3f3f3f3f)
            return 0;
        else 
            total += g[ans[i-1]][ans[i]];
    }
    return total;
}
int main()
{
    memset(g,0x3f3f3f3f,sizeof(g));
    cin>>n>>m;
    int a,b,c;
    for(int i = 0; i < m;i++)
    {
        cin>>a>>b>>c;
        g[a][b] = g[b][a] = c;
    }
    cin>>k;
    int min_dis = 1<<30,min_index,cnt = 0;
    for(int i = 1;i <= k;i++)
    {
        int t = judge();
        if(t)
        {
            cnt++;
            if(t < min_dis)
            {
                min_dis = t;
                min_index = i;
            }
        }
    }
    printf("%d\n",cnt);
    printf("%d %d\n",min_index,min_dis);
    return 0;
}
```

### **L3-1 森森美图 (30 分)**

> 向量空间，`bfs`,最短路
>
> 对于`double`类型的数组，不要用`memset`赋值
>
> ```c++
> 1。void *memset(void *s,int c,size_t n)
> 总的作用：将已开辟内存空间 s 的首 n 个字节的值设为值 c。
> ```
>

```c++
#include<iostream>
#include<queue>
#include<map>
#include<cmath>

using namespace std;
typedef pair<int,int> P;
const int N = 110;
int n,m,sx,sy,ex,ey;
double dis[N][N];
double cost[N][N];
int dx[8] = {-1,1,0,0,-1,-1,1,1};
int dy[8] = {0,0,1,-1,-1,1,-1,1};
int ischeck(P point)
{
    // a (sx,sy)  b(ex,ey) c(x,y)
    //a->b (ex-sx,ey-sy),
    //a->c(x-sx,y-sy)
    //a->b x a—>c  (ex-sx)*(y-sy) - (ey-sy)*(x-sx)
    return (ex-sx)*(point.second -sy) - (ey - sy)*(point.first - sx);
}
bool judge(bool flag,int x,int y)
{
    if(x == ex && y == ey)return true;
    if(x < 0 || x >= n || y < 0 || y >= m)return false;
    int tmp = ischeck(P(x,y));
    if((tmp > 0 && flag) || (tmp < 0 && !flag))return true;
    return false;
}
void bfs(bool flag)
{
    for(int i = 0; i < n;i++)
        for(int j = 0;j < m;j++)
            dis[i][j] = 0x3f3f3f3f;
    
    queue<P> pq;
    dis[sx][sy] = cost[sx][sy]; 
    pq.push(P(sx,sy));

    while(!pq.empty())
    {
        auto v = pq.front();
        pq.pop();

        int x = v.first,y = v.second;

        for(int i = 0;i < 8;i++)
        {
            int nx = x + dx[i],ny = y + dy[i];
            if(judge(flag,nx,ny))
            {
                double tmp = dis[x][y] + cost[nx][ny];
                if(i > 3)
                    tmp += (cost[nx][ny] + cost[x][y])*(sqrt(2) - 1);
                if(dis[nx][ny] > tmp)
                {
                    dis[nx][ny] = tmp;
                    pq.push(P(nx,ny));
                }
            }
        }
    }
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i = 0;i < n;i++)
        for(int j = 0;j < m;j++)
            scanf("%lf",&cost[i][j]);
    scanf("%d %d %d %d",&sy,&sx,&ey,&ex);
    bfs(true);
    double ans = dis[ex][ey];
    bfs(false);
    ans += dis[ex][ey];
    printf("%.2f",ans - cost[sx][sy] - cost[ex][ey]);
    return 0;
}
```

### **L3-2 狼人杀 (30 分)**

> dfs，枚举狼人。注意:恢复现场信息

```c++
#include<iostream>
#include<vector>
#include<set>
#include<cmath>

using namespace std;
const int N = 110;
int a[N];
int  n,m,l;
set<int> st;
void dfs(int index,bool &f)
{
    //从n到1枚举狼人，
    if(index <= 0 || st.size() == m)//枚举完成或者枚举了m个狼人
    {
        if(st.size() == m)//m个狼人
        {
            int liars = 0,wolferliars = 0;//说谎的人，说谎的狼人
            for(int i = 1;i <= n;i++)
            {
                if(a[i] > 0 ^ st.find(abs(a[i])) == st.end())//i人说谎（a[i] > 0 但是 asb(a[i])为狼人）
                {
                    liars++;
                    if(st.find(i) != st.end())
                        ++wolferliars;
                }
            }
            //l个人说谎，不是所有的狼人都说谎
            if(liars == l && wolferliars > 0 && wolferliars < m)
                 f = true;
        }
        return ;
    }

    //index为狼人
    st.insert(index);
    dfs(index - 1,f);
    //找到狼人直接结束
    if(f)
        return;
    //index不是狼人 
    st.erase(index);
    dfs(index - 1,f);
}
int main()
{
    cin>>n>>m>>l;
    char c;
    int temp;
    for(int i = 1;i <= n;i++)
    {
        cin>>c>>temp;
        if(c == '-')
        {
            a[i] = 0 - temp;
        }
        else
        {
            a[i] = temp;
        }
    }

    bool f = false;
    dfs(n,f);
    if(st.size() != 0)
    {
        for(auto it = st.rbegin();it != st.rend();it++)
        {
            printf("%s%d",(it == st.rbegin() ? "" : " "),*it);
        }
    }
    else 
    {
        printf("No Solution\n");
    }
    return 0;
}
```

### **L3-3 可怜的复杂度 (30 分)**

> 

```c++

```

